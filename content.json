{"meta":{"title":"xiaOz's blog","subtitle":null,"description":null,"author":"xiaOz","url":"https://blog.xiaoz.site","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-09-06T06:15:25.718Z","updated":"2019-09-06T06:15:25.718Z","comments":true,"path":"404.html","permalink":"https://blog.xiaoz.site/404.html","excerpt":"","text":"404 Not Found **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2019-09-06T06:15:25.727Z","updated":"2019-09-06T06:15:25.727Z","comments":true,"path":"doc/index.html","permalink":"https://blog.xiaoz.site/doc/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-09-06T06:15:25.726Z","updated":"2019-09-06T06:15:25.726Z","comments":true,"path":"categories/index.html","permalink":"https://blog.xiaoz.site/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-01-21T02:10:38.052Z","updated":"2021-01-21T02:10:38.052Z","comments":true,"path":"about/index.html","permalink":"https://blog.xiaoz.site/about/index.html","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前端码农一枚，菜的抠脚，但是在不断地学习进步ing"},{"title":"所有标签","date":"2019-09-06T06:15:25.727Z","updated":"2019-09-06T06:15:25.727Z","comments":true,"path":"tags/index.html","permalink":"https://blog.xiaoz.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据类型","slug":"interview/1.数据类型","date":"2021-01-21T01:55:37.000Z","updated":"2021-01-21T02:04:51.377Z","comments":true,"path":"2021/01/21/interview/1.数据类型/","link":"","permalink":"https://blog.xiaoz.site/2021/01/21/interview/1.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"八种数据类型： undefined, Null, Boolean, String, Number, Symbol, BigInt, Object 其中前七种是基础类型，Object 是引用类型 判断类型1. typeof12345678910typeof 1 // 'number'typeof '1' // 'string'typeof undefined // 'undefined'typeof true // 'boolean'typeof Symbol() // 'symbol'typeof null // 'object'typeof [] // 'object'typeof &#123;&#125; // 'object'typeof console // 'object'typeof console.log // 'function' 虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象，判断是否为 null，直接通过 ===null 引用类型除了function其他都会输出 object","text":"八种数据类型： undefined, Null, Boolean, String, Number, Symbol, BigInt, Object 其中前七种是基础类型，Object 是引用类型 判断类型1. typeof12345678910typeof 1 // 'number'typeof '1' // 'string'typeof undefined // 'undefined'typeof true // 'boolean'typeof Symbol() // 'symbol'typeof null // 'object'typeof [] // 'object'typeof &#123;&#125; // 'object'typeof console // 'object'typeof console.log // 'function' 虽然 typeof null 会输出 object，但这只是 JS 存在的一个悠久 Bug，不代表 null 就是引用数据类型，并且 null 本身也不是对象，判断是否为 null，直接通过 ===null 引用类型除了function其他都会输出 object 2. instanceof1234let car = new String('Mercedes Benz')car instanceof String // truelet str = 'Covid-19'str instanceof String // false instanceof 可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型； 3. Object.prototype.toString对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用 12345678910111213Object.prototype.toString(&#123;&#125;) // \"[object Object]\"Object.prototype.toString.call(&#123;&#125;) // 同上结果，加上call也okObject.prototype.toString.call(1) // \"[object Number]\"Object.prototype.toString.call('1') // \"[object String]\"Object.prototype.toString.call(true) // \"[object Boolean]\"Object.prototype.toString.call(function()&#123;&#125;) // \"[object Function]\"Object.prototype.toString.call(null) //\"[object Null]\"Object.prototype.toString.call(undefined) //\"[object Undefined]\"Object.prototype.toString.call(/123/g) //\"[object RegExp]\"Object.prototype.toString.call(new Date()) //\"[object Date]\"Object.prototype.toString.call([]) //\"[object Array]\"Object.prototype.toString.call(document) //\"[object HTMLDocument]\"Object.prototype.toString.call(window) //\"[object Window]\" 使用这个方法最后返回统一字符串格式为 “[object Xxx]” ，而这里字符串里面的 “Xxx” ，第一个首字母要大写（注意：使用 typeof 返回的是小写） 数据类型转换1. 强制类型转换强制类型转换方式包括 Number()、parseInt()、parseFloat()、toString()、String()、Boolean() Number() 方法的强制转换规则 如果是布尔值，true 和 false 分别被转换为 1 和 0； 如果是数字，返回自身； 如果是 null，返回 0； 如果是 undefined，返回 NaN； 如果是字符串，遵循以下规则：如果字符串中只包含数字（或者是 0X / 0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN； 如果是 Symbol，抛出错误； 如果是对象，并且部署了 [Symbol.toPrimitive] ，那么调用此方法，否则调用对象的 valueOf() 方法，然后依据前面的规则转换返回的值；如果转换的结果是 NaN ，则调用对象的 toString() 方法，再次依照前面的顺序转换返回对应的值（Object 转换规则会在下面细讲）。 12345678Number(true); // 1Number(false); // 0Number('0111'); //111Number(null); //0Number(''); //0Number('1a'); //NaNNumber(-0X11); //-17Number('0X11') //17 Boolean() 方法的强制转换规则这个方法的规则是：除了 undefined、 null、 false、 ‘’、 0（包括 +0，-0）、 NaN 转换出来是 false，其他都是 true。 2. 隐式类型转换凡是通过逻辑运算符 (&amp;&amp;、 ||、 !)、运算符 (+、-、*、/)、关系操作符 (&gt;、 &lt;、 &lt;= 、&gt;=)、相等运算符 (==) 或者 if/while 条件的操作，如果遇到两个数据类型不一样的情况，都会出现隐式类型转换。 ‘==’ 的隐式类型转换规则 如果类型相同，无须进行类型转换； 如果其中一个操作值是 null 或者 undefined，那么另一个操作符必须为 null 或者 undefined，才会返回 true，否则都返回 false； 如果其中一个是 Symbol 类型，那么返回 false； 两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number； 如果一个操作值是 boolean，那么转换成 number； 如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（调用 object 的 valueOf/toString 方法进行转换，valueOf优先）。 12345678910111213141516null == undefined // true 规则2null == 0 // false 规则2'' == null // false 规则2'' == 0 // true 规则4 字符串转隐式转换成Number之后再对比'123' == 123 // true 规则4 字符串转隐式转换成Number之后再对比0 == false // true e规则 布尔型隐式转换成Number之后再对比1 == true // true e规则 布尔型隐式转换成Number之后再对比var a = &#123; value: 0, valueOf: function() &#123; this.value++; return this.value; &#125;&#125;;// 注意这里a又可以等于1、2、3console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3); //true f规则 Object隐式转换 ‘+’ 的隐式类型转换规则 如果其中有一个是字符串，另外一个是 undefined、null 或布尔型，则调用 toString() 方法进行字符串拼接；如果是纯对象、数组、正则等，则默认调用对象的转换方法会存在优先级，然后再进行拼接。 如果其中有一个是数字，另外一个是 undefined、null、布尔型或数字，则会将其转换成数字进行加法运算，对象的情况还是参考上一条规则。 如果其中一个是字符串、一个是数字，则按照字符串规则进行拼接。 1234567891011121 + 2 // 3 常规情况'1' + '2' // '12' 常规情况// 下面看一下特殊情况'1' + undefined // \"1undefined\" 规则1，undefined转换字符串'1' + null // \"1null\" 规则1，null转换字符串'1' + true // \"1true\" 规则1，true转换字符串'1' + 1n // '11' 比较特殊字符串和BigInt相加，BigInt转换为字符串1 + undefined // NaN 规则2，undefined转换数字相加NaN1 + null // 1 规则2，null转换为01 + true // 2 规则2，true转换为1，二者相加为21 + 1n // 错误 不能把BigInt和Number类型直接混合相加'1' + 3 // '13' 规则3，字符串拼接 Object 的转换规则 如果部署了 Symbol.toPrimitive 方法，优先调用再返回； 调用 valueOf()，如果转换为基础类型，则返回； 调用 toString()，如果转换为基础类型，则返回； 如果都没有返回基础类型，会报错。 12345678910111213141516171819var obj = &#123; value: 1, valueOf() &#123; return 2; &#125;, toString() &#123; return '3' &#125;, [Symbol.toPrimitive]() &#123; return 4 &#125;&#125;console.log(obj + 1); // 输出5// 因为有Symbol.toPrimitive，就优先执行这个；如果Symbol.toPrimitive这段代码删掉，则执行valueOf打印结果为3；如果valueOf也去掉，则调用toString返回'31'(字符串拼接)// 再看两个特殊的case：10 + &#123;&#125;// \"10[object Object]\"，注意：&#123;&#125;会默认调用valueOf是&#123;&#125;，不是基础类型继续转换，调用toString，返回结果\"[object Object]\"，于是和10进行'+'运算，按照字符串拼接规则来，参考'+'的规则C[1,2,undefined,4,5] + 10// \"1,2,,4,510\"，注意[1,2,undefined,4,5]会默认先调用valueOf结果还是这个数组，不是基础数据类型继续转换，也还是调用toString，返回\"1,2,,4,5\"，然后再和10进行运算，还是按照字符串拼接规则，参考'+'的第3条规则","categories":[{"name":"面试","slug":"面试","permalink":"https://blog.xiaoz.site/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.xiaoz.site/tags/js/"}]},{"title":"继承","slug":"interview/3.继承","date":"2021-01-21T01:55:37.000Z","updated":"2021-01-21T02:04:50.412Z","comments":true,"path":"2021/01/21/interview/3.继承/","link":"","permalink":"https://blog.xiaoz.site/2021/01/21/interview/3.%E7%BB%A7%E6%89%BF/","excerpt":"原型链123456789function Parent1() &#123; this.name = \"parent1\"; this.play = [1, 2, 3];&#125;function Child1() &#123; this.type = \"child2\";&#125;Child1.prototype = new Parent1();console.log(new Child1());","text":"原型链123456789function Parent1() &#123; this.name = \"parent1\"; this.play = [1, 2, 3];&#125;function Child1() &#123; this.type = \"child2\";&#125;Child1.prototype = new Parent1();console.log(new Child1());","categories":[{"name":"面试","slug":"面试","permalink":"https://blog.xiaoz.site/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.xiaoz.site/tags/js/"}]},{"title":"深浅拷贝","slug":"interview/2.深浅拷贝","date":"2021-01-21T01:55:37.000Z","updated":"2021-01-21T02:04:45.830Z","comments":true,"path":"2021/01/21/interview/2.深浅拷贝/","link":"","permalink":"https://blog.xiaoz.site/2021/01/21/interview/2.%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"浅拷贝1. Object.assign 它不会拷贝对象的继承属性； 它不会拷贝对象的不可枚举的属性； 可以拷贝 Symbol 类型的属性。 2.扩展运算符 …和 Object.assign 类似","text":"浅拷贝1. Object.assign 它不会拷贝对象的继承属性； 它不会拷贝对象的不可枚举的属性； 可以拷贝 Symbol 类型的属性。 2.扩展运算符 …和 Object.assign 类似 深拷贝1. JSON.stringfy先 JSON.stringfy 再 JSON.parse 拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失； 拷贝 Date 引用类型会变成字符串； 无法拷贝不可枚举的属性； 无法拷贝对象的原型链； 拷贝 RegExp 引用类型会变成空对象； 对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null； 无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。 2. 简单递归12345678910111213141516171819let obj1 = &#123; a:&#123; b:1 &#125;&#125;function deepClone(obj) &#123; let cloneObj = &#123;&#125; for(let key in obj) &#123; //遍历 if(typeof obj[key] ==='object') &#123; cloneObj[key] = deepClone(obj[key]) //是对象就再次调用该函数递归 &#125; else &#123; cloneObj[key] = obj[key] //基本类型的话直接复制值 &#125; &#125; return cloneObj&#125;let obj2 = deepClone(obj1);obj1.a.b = 2;console.log(obj2); // &#123;a:&#123;b:1&#125;&#125; 这个深拷贝函数并不能复制不可枚举的属性以及 Symbol 类型； 这种方法只是针对普通的引用类型的值做递归复制，而对于 Array、Date、RegExp、Error、Function 这样的引用类型并不能正确地拷贝； 对象的属性里面成环，即循环引用没有解决。 3. 复杂递归1234567891011121314151617181920212223242526272829303132333435363738394041const isComplexDataType = obj =&gt; (typeof obj === 'object' || typeof obj === 'function') &amp;&amp; (obj !== null)const deepClone = function (obj, hash = new WeakMap()) &#123; if (obj.constructor === Date) return new Date(obj) // 日期对象直接返回一个新的日期对象 if (obj.constructor === RegExp) return new RegExp(obj) //正则对象直接返回一个新的正则对象 //如果循环引用了就用 weakMap 来解决 if (hash.has(obj)) return hash.get(obj) let allDesc = Object.getOwnPropertyDescriptors(obj) //遍历传入参数所有键的特性 let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc) //继承原型链 hash.set(obj, cloneObj) for (let key of Reflect.ownKeys(obj)) &#123; cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; typeof obj[key] !== 'function') ? deepClone(obj[key], hash) : obj[key] &#125; return cloneObj&#125;// 下面是验证代码let obj = &#123; num: 0, str: '', boolean: true, unf: undefined, nul: null, obj: &#123; name: '我是一个对象', id: 1 &#125;, arr: [0, 1, 2], func: function () &#123; console.log('我是一个函数') &#125;, date: new Date(0), reg: new RegExp('/我是一个正则/ig'), [Symbol('1')]: 1,&#125;;Object.defineProperty(obj, 'innumerable', &#123; enumerable: false, value: '不可枚举属性' &#125;);obj = Object.create(obj, Object.getOwnPropertyDescriptors(obj))obj.loop = obj // 设置loop成循环引用的属性let cloneObj = deepClone(obj)cloneObj.arr.push(4)console.log('obj', obj)console.log('cloneObj', cloneObj) 针对能够遍历对象的不可枚举属性以及 Symbol 类型，我们可以使用 Reflect.ownKeys 方法； 当参数为 Date、RegExp 类型，则直接生成一个新的实例返回； 利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链； 利用 WeakMap 类型作为 Hash 表，因为 WeakMap 是弱引用类型，可以有效防止内存泄漏（你可以关注一下 Map 和 weakMap 的关键区别，这里要用 weakMap），作为检测循环引用很有帮助，如果存在循环，则引用直接返回 WeakMap 存储的值。","categories":[{"name":"面试","slug":"面试","permalink":"https://blog.xiaoz.site/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.xiaoz.site/tags/js/"}]},{"title":"xampp-mysql","slug":"xampp-mysql","date":"2019-09-06T06:19:40.000Z","updated":"2019-09-06T06:21:24.451Z","comments":true,"path":"2019/09/06/xampp-mysql/","link":"","permalink":"https://blog.xiaoz.site/2019/09/06/xampp-mysql/","excerpt":"","text":"xampp 下 mysql 初始密码的修改首先，我们点击 xampp 中的 shell 按钮，登陆 mysql：c:&gt;mysql -u root -p ，然后密码直接回车。 现在，应该进入 mysql 了，输入下面这条指令： 1mysql&gt;set password for 'root'@'localhost'=password('newpasswd');","categories":[{"name":"learn","slug":"learn","permalink":"https://blog.xiaoz.site/categories/learn/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://blog.xiaoz.site/tags/tips/"}]},{"title":"深入浅出 React Hooks","slug":"react-hook","date":"2019-06-04T01:22:52.000Z","updated":"2019-09-06T06:15:25.724Z","comments":true,"path":"2019/06/04/react-hook/","link":"","permalink":"https://blog.xiaoz.site/2019/06/04/react-hook/","excerpt":"直播回放链接：云栖社区 (@x-cold) React Hooks 是什么？Hooks 顾名思义，字面意义上来说就是 React 钩子的概念。通过一个 case 我们对 React Hooks 先有一个第一印象。 假设现在要实现一个计数器的组件。如果使用组件化的方式，我们需要做的事情相对更多一些，比如说声明 state，编写计数器的方法等，而且需要理解的概念可能更多一些，比如 Javascript 的类的概念，this 上下文的指向等。 示例 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends React.Component &#123; state = &#123; count: 0 &#125; countUp = () =&gt; &#123; const &#123; count &#125; = this.state; this.setState(&#123; count: count + 1 &#125;); &#125; countDown = () =&gt; &#123; const &#123; count &#125; = this.state; this.setState(&#123; count: count - 1 &#125;); &#125; render() &#123; const &#123; count &#125; = this.state; return ( &lt;div&gt; &lt;button onClick=&#123;this.countUp&#125;&gt;+&lt;/button&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.countDown&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter /&gt;, document.getElementById('root')); 使用 React Hooks，我们可以这么写。","text":"直播回放链接：云栖社区 (@x-cold) React Hooks 是什么？Hooks 顾名思义，字面意义上来说就是 React 钩子的概念。通过一个 case 我们对 React Hooks 先有一个第一印象。 假设现在要实现一个计数器的组件。如果使用组件化的方式，我们需要做的事情相对更多一些，比如说声明 state，编写计数器的方法等，而且需要理解的概念可能更多一些，比如 Javascript 的类的概念，this 上下文的指向等。 示例 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Counter extends React.Component &#123; state = &#123; count: 0 &#125; countUp = () =&gt; &#123; const &#123; count &#125; = this.state; this.setState(&#123; count: count + 1 &#125;); &#125; countDown = () =&gt; &#123; const &#123; count &#125; = this.state; this.setState(&#123; count: count - 1 &#125;); &#125; render() &#123; const &#123; count &#125; = this.state; return ( &lt;div&gt; &lt;button onClick=&#123;this.countUp&#125;&gt;+&lt;/button&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;this.countDown&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter /&gt;, document.getElementById('root')); 使用 React Hooks，我们可以这么写。 示例 123456789101112131415import React, &#123; useState &#125; from 'react';import ReactDOM from 'react-dom';function Counter() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; )&#125;ReactDOM.render(&lt;Counter /&gt;, document.getElementById('root')); 通过上面的例子，显而易见的是 React Hooks 提供了一种简洁的、函数式（FP）的程序风格，通过纯函数组件和可控的数据流来实现状态到 UI 的交互（MVVM）。 Hooks API Basic Hooks useState useEffect useContext Additional Hooks useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue useStateuseState 是最基本的 API，它传入一个初始值，每次函数执行都能拿到新值。 123456789101112131415import React, &#123; useState &#125; from 'react';import ReactDOM from 'react-dom';function Counter() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; )&#125;ReactDOM.render(&lt;Counter /&gt;, document.getElementById('root')); 需要注意的是，通过 useState 得到的状态 count，在 Counter 组件中的表现为一个常量，每一次通过 setCount 进行修改后，又重新通过 useState 获取到一个新的常量。 useReduceruseReducer 和 useState 几乎是一样的，需要外置外置 reducer (全局)，通过这种方式可以对多个状态同时进行控制。仔细端详起来，其实跟 redux 中的数据流的概念非常接近。 123456789101112131415161718192021222324import &#123; useState, useReducer &#125; from 'react';import ReactDOM from 'react-dom';function reducer(state, action) &#123; switch (action.type) &#123; case 'up': return &#123; count: state.count + 1 &#125;; case 'down': return &#123; count: state.count - 1 &#125;; &#125;&#125;function Counter() &#123; const [state, dispatch] = useReducer(reducer, &#123; count: 1 &#125;) return ( &lt;div&gt; &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'up' &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'down' &#125;)&#125;&gt;+&lt;/button&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;Counter /&gt;, document.getElementById('root')); useEffect一个至关重要的 Hooks API，顾名思义，useEffect 是用于处理各种状态变化造成的副作用，也就是说只有在特定的时刻，才会执行的逻辑。 123456789101112131415161718192021222324252627import &#123; useState, useEffect &#125; from 'react';import ReactDOM from 'react-dom';function Example() &#123; const [count, setCount] = useState(0); // =&gt; componentDidMount/componentDidUpdate useEffect(() =&gt; &#123; // update document.title = `You clicked $&#123;count&#125; times`; // =&gt; componentWillUnMount return function cleanup() &#123; document.title = 'app'; &#125; &#125;, [count]); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;Example /&gt;, document.getElementById('root')); useMemouseMemo 主要用于渲染过程优化，两个参数依次是计算函数（通常是组件函数）和依赖状态列表，当依赖的状态发生改变时，才会触发计算函数的执行。如果没有指定依赖，则每一次渲染过程都会执行该计算函数。 1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 123456789101112131415161718192021222324import &#123; useState, useMemo &#125; from 'react';import ReactDOM from 'react-dom';function Time() &#123; return &lt;p&gt;&#123;Date.now()&#125;&lt;/p&gt;;&#125;function Counter() &#123; const [count, setCount] = useState(0); const memoizedChildComponent = useMemo((count) =&gt; &#123; return &lt;Time /&gt;; &#125;, [count]); return ( &lt;div&gt; &lt;h1&gt;&#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt; &lt;div&gt;&#123;memoizedChildComponent&#125;&lt;/div&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;Counter /&gt;, document.getElementById('root')); useContextcontext 是在外部 create ，内部 use 的 state，它和全局变量的区别在于，如果多个组件同时 useContext，那么这些组件都会 rerender，如果多个组件同时 useState 同一个全局变量，则只有触发 setState 的当前组件 rerender。 示例-未使用 useContext 123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; useState, useContext, createContext &#125; from 'react';import ReactDOM from 'react-dom';// 1. 使用 createContext 创建上下文const UserContext = new createContext();// 2. 创建 Providerconst UserProvider = props =&gt; &#123; let [username, handleChangeUsername] = useState(''); return ( &lt;UserContext.Provider value=&#123;&#123; username, handleChangeUsername &#125;&#125;&gt; &#123;props.children&#125; &lt;/UserContext.Provider&gt; );&#125;;// 3. 创建 Consumerconst UserConsumer = UserContext.Consumer;// 4. 使用 Consumer 包裹组件const Pannel = () =&gt; ( &lt;UserConsumer&gt; &#123;(&#123; username, handleChangeUsername &#125;) =&gt; ( &lt;div&gt; &lt;div&gt;user: &#123;username&#125;&lt;/div&gt; &lt;input onChange=&#123;e =&gt; handleChangeUsername(e.target.value)&#125; /&gt; &lt;/div&gt; )&#125; &lt;/UserConsumer&gt;);const Form = () =&gt; &lt;Pannel /&gt;;const App = () =&gt; ( &lt;div&gt; &lt;UserProvider&gt; &lt;Form /&gt; &lt;/UserProvider&gt; &lt;/div&gt;);ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 示例 - 使用 useContext 12345678910111213141516171819202122232425262728293031323334353637import &#123; useState, useContext, createContext &#125; from 'react';import ReactDOM from 'react-dom';// 1. 使用 createContext 创建上下文const UserContext = new createContext();// 2. 创建 Providerconst UserProvider = props =&gt; &#123; let [username, handleChangeUsername] = useState(''); return ( &lt;UserContext.Provider value=&#123;&#123; username, handleChangeUsername &#125;&#125;&gt; &#123;props.children&#125; &lt;/UserContext.Provider&gt; );&#125;;const Pannel = () =&gt; &#123; const &#123; username, handleChangeUsername &#125; = useContext(UserContext); // 3. 使用 Context return ( &lt;div&gt; &lt;div&gt;user: &#123;username&#125;&lt;/div&gt; &lt;input onChange=&#123;e =&gt; handleChangeUsername(e.target.value)&#125; /&gt; &lt;/div&gt; );&#125;;const Form = () =&gt; &lt;Pannel /&gt;;const App = () =&gt; ( &lt;div&gt; &lt;UserProvider&gt; &lt;Form /&gt; &lt;/UserProvider&gt; &lt;/div&gt;);ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); useRefuseRef 返回一个可变的 ref 对象，其 .current 属性初始化为传递的参数（initialValue）。返回的对象将持续整个组件的生命周期。事实上 useRef 是一个非常有用的 API，许多情况下，我们需要保存一些改变的东西，它会派上大用场的。 示例 12345678910111213function TextInputWithFocusButton() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; // `current` points to the mounted text input element inputEl.current.focus(); &#125;; return ( &lt;&gt; &lt;input ref=&#123;inputEl&#125; type=\"text\" /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/&gt; );&#125; React 状态共享方案说到状态共享，最简单和直接的方式就是通过 props 逐级进行状态的传递，这种方式耦合于组件的父子关系，一旦组件嵌套结构发生变化，就需要重新编写代码，维护成本非常昂贵。随着时间的推移，官方推出了各种方案来解决状态共享和代码复用的问题。 MixinsReact 中，只有通过 createClass 创建的组件才能使用 mixins。这种高耦合，依赖难以控制，复杂度高的方式随着 ES6 的浪潮逐渐淡出了历史舞台。 HOC高阶组件源于函数式编程，由于 React 中的组件也可以视为函数（类），因此天生就可以通过 HOC 的方式来实现代码复用。可以通过属性代理和反向继承来实现，HOC 可以很方便的操控渲染的结果，也可以对组件的 props / state 进行操作，从而可以很方便的进行复杂的代码逻辑复用。 12345678910111213141516171819202122232425262728293031323334import React from 'react';import PropTypes from 'prop-types';// 属性代理class Show extends React.Component &#123; static propTypes = &#123; children: PropTypes.element, visible: PropTypes.bool, &#125;; render() &#123; const &#123; visible, children &#125; = this.props; return visible ? children : null; &#125;&#125;// 反向继承function Show2(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; if (this.props.visible === false) &#123; return null; &#125; else &#123; return super.render(); &#125; &#125; &#125;&#125;function App() &#123; return ( &lt;Show visible=&#123;Math.random() &gt; 0.5&#125;&gt;hello&lt;/Show&gt; );&#125; Redux 中的状态复用是一种典型的 HOC 的实现，我们可以通过 compose 来将数据组装到目标组件中，当然你也可以通过装饰器的方式进行处理。 12345678910111213import React from 'react';import &#123; connect &#125; from 'react-redux';// use decorator@connect(state =&gt; (&#123; name: state.user.name &#125;))class App extends React.Component&#123; render() &#123; return &lt;div&gt;hello, &#123;this.props.name&#125;&lt;/div&gt; &#125;&#125;// use composeconnect((state) =&gt; (&#123; name: state.user.name &#125;))(App); Render Props显而易见，renderProps 就是一种将 render 方法作为 props 传递到子组件的方案，相比 HOC 的方案，renderProps 可以保护原有的组件层次结构。 12345678910111213141516171819202122232425262728293031323334353637383940import React from 'react';import ReactDOM from 'react-dom';import PropTypes from 'prop-types';// 与 HOC 不同，我们可以使用具有 render prop 的普通组件来共享代码class Mouse extends React.Component &#123; static propTypes = &#123; render: PropTypes.func.isRequired &#125; state = &#123; x: 0, y: 0 &#125;; handleMouseMove = (event) =&gt; &#123; this.setState(&#123; x: event.clientX, y: event.clientY &#125;); &#125; render() &#123; return ( &lt;div style=&#123;&#123; height: '100%' &#125;&#125; onMouseMove=&#123;this.handleMouseMove&#125;&gt; &#123;this.props.render(this.state)&#125; &lt;/div&gt; ); &#125;&#125;function App() &#123; return ( &lt;div style=&#123;&#123; height: '100%' &#125;&#125;&gt; &lt;Mouse render=&#123;(&#123; x, y &#125;) =&gt; ( // render prop 给了我们所需要的 state 来渲染我们想要的 &lt;h1&gt;The mouse position is (&#123;x&#125;, &#123;y&#125;)&lt;/h1&gt; )&#125;/&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;App/&gt;, document.getElementById('root')); Hooks通过组合 Hooks API 和 React 内置的 Context，从前面的示例可以看到通过 Hook 让组件之间的状态共享更清晰和简单。 React Hooks 设计理念 基本原理 12345function FunctionalComponent () &#123; const [state1, setState1] = useState(1); const [state2, setState2] = useState(2); const [state3, setState3] = useState(3);&#125; 12345678910&#123; memoizedState: 'foo', next: &#123; memoizedState: 'bar', next: &#123; memoizedState: 'bar', next: null &#125; &#125;&#125; 函数式贯彻到底 capture props函数组件天生就是支持 props 的，基本用法上和 class 组件没有太大的差别。需要注意的两个区别是： class 组件 props 挂载在 this 上下文中，而函数式组件通过形参传入； 由于挂载位置的差异，class 组件中如果 this 发生了变化，那么 this.props 也会随之改变；而在函数组件里 props 始终是不可变的，因此遵守 capture value 原则（即获取的值始终是某一时刻的），Hooks 也遵循这个原则。 通过一个示例来理解一下 capture value，我们可以通过 useRef 来规避 capture value，因为 useRef 是可变的。 state class 组件 函数组件 创建状态 this.state = {} useState, useReducer 修改状态 this.setState() set function 更新机制 异步更新，多次修改合并到上一个状态，产生一个副本 同步更新，直接修改为目标状态 状态管理 一个 state 集中式管理多个状态 多个 state，可以通过 useReducer 进行状态合并（手动） 性能 高 如果 useState 初始化状态需要通过非常复杂的计算得到，请使用函数的声明方式，否则每次渲染都会重复执行 生命周期 componentDidMount / componentDidUpdate / componentWillUnMount useEffect 在每一次渲染都会被调用，稍微包装一下就可以作为这些生命周期使用； shouldComponentUpdate 通常我们优化组件性能时，会优先采用纯组件的方式来减少单个组件的渲染次数。 1class Button extends React.PureComponent &#123;&#125; React Hooks 中可以采用 useMemo 代替，可以实现仅在某些数据变化时重新渲染组件，等同于自带了 shallowEqual 的 shouldComponentUpdate。 强制渲染 forceUpdate由于默认情况下，每一次修改状态都会造成重新渲染，可以通过一个不使用的 set 函数来当成 forceUpdate。 1const forceUpdate = () =&gt; useState(0)[1]; 实现原理 基于 Hooks，增强 Hooks 来一套组合拳吧！由于每一个 Hooks API 都是纯函数的概念，使用时更关注输入 (input) 和输出 (output)，因此可以更好的通过组装函数的方式，对不同特性的基础 Hooks API 进行组合，创造拥有新特性的 Hooks。 useState 维护组件状态 useEffect 处理副作用 useContext 监听 provider 更新变化 useDidMount12345import &#123; useEffect &#125; from 'react';const useDidMount = fn =&gt; useEffect(() =&gt; fn &amp;&amp; fn(), []);export default useDidMount; useDidUpdate123456789101112131415import &#123; useEffect, useRef &#125; from 'react';const useDidUpdate = (fn, conditions) =&gt; &#123; const didMoutRef = useRef(false); useEffect(() =&gt; &#123; if (!didMoutRef.current) &#123; didMoutRef.current = true; return; &#125; // Cleanup effects when fn returns a function return fn &amp;&amp; fn(); &#125;, conditions);&#125;;export default useDidUpdate useWillUnmount在讲到 useEffect 时已经提及过，其允许返回一个 cleanup 函数，组件在取消挂载时将会执行该 cleanup 函数，因此 useWillUnmount 也能轻松实现~ 12345import &#123; useEffect &#125; from 'react';const useWillUnmount = fn =&gt; useEffect(() =&gt; () =&gt; fn &amp;&amp; fn(), []);export default useWillUnmount; useHover示例 123456789101112131415// lib/onHover.jsimport &#123; useState &#125; from 'react';const useHover = () =&gt; &#123; const [hovered, set] = useState(false); return &#123; hovered, bind: &#123; onMouseEnter: () =&gt; set(true), onMouseLeave: () =&gt; set(false), &#125;, &#125;;&#125;;export default useHover; 12345678910111213import &#123; useHover &#125; from './lib/onHover.js';function Hover() &#123; const &#123; hovered, bind &#125; = useHover(); return ( &lt;div&gt; &lt;div &#123;...bind&#125;&gt; hovered: &#123;String(hovered)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; useField示例 12345678910111213141516171819// lib/useField.jsimport &#123; useState &#125; from 'react';const useField = (initial) =&gt; &#123; const [value, set] = useState(initial); return &#123; value, set, reset: () =&gt; set(initial), bind: &#123; value, onChange: e =&gt; set(e.target.value), &#125;, &#125;;&#125;export default useField; 123456789101112131415161718192021222324252627import &#123; useField &#125; from 'lib/useField';function Input &#123; const &#123; value, bind &#125; = useField('Type Here...'); return ( &lt;div&gt; input text: &#123;value&#125; &lt;input type=\"text\" &#123;...bind&#125; /&gt; &lt;/div&gt; );&#125;function Select() &#123; const &#123; value, bind &#125; = useField('apple') return ( &lt;div&gt; selected: &#123;value&#125; &lt;select &#123;...bind&#125;&gt; &lt;option value=\"apple\"&gt;apple&lt;/option&gt; &lt;option value=\"orange\"&gt;orange&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; );&#125; 注意事项 Hook 的使用范围：函数式的 React 组件中、自定义的 Hook 函数里； Hook 必须写在函数的最外层，每一次 useState 都会改变其下标 (cursor)，React 根据其顺序来更新状态； 尽管每一次渲染都会执行 Hook API，但是产生的状态 (state) 始终是一个常量（作用域在函数内部）； 结语React Hooks 提供为状态管理提供了新的可能性，尽管我们可能需要额外去维护一些内部的状态，但是可以避免通过 renderProps / HOC 等复杂的方式来处理状态管理的问题。Hooks 带来的好处如下： 更细粒度的代码复用，并且不会产生过多的副作用 函数式编程风格，代码更简洁，同时降低了使用和理解门槛 减少组件嵌套层数 组件数据流向更清晰 事实上，通过定制各种场景下的自定义 Hooks，能让我们的应用程序更方便和简洁，组件的层次结构也能保证完好，还有如此令人愉悦的函数式编程风格，Hooks 在 React 16.8.0 版本已经正式发布稳定版本，现在开始用起来吧！！！ 参考资料 hooks-reference react-hooks-lib 【React深入】从Mixin到HOC再到Hook How Are Function Components Different from Classes? under-the-hood-of-reacts-hooks-system 阅读源码后，来讲讲React Hooks是怎么实现的 转载至 深入浅出 React Hooks","categories":[{"name":"learn","slug":"learn","permalink":"https://blog.xiaoz.site/categories/learn/"}],"tags":[{"name":"react","slug":"react","permalink":"https://blog.xiaoz.site/tags/react/"}]},{"title":"typescript学习(7) 高级类型","slug":"learn-ts7","date":"2019-05-18T14:00:09.000Z","updated":"2019-09-06T06:15:25.723Z","comments":true,"path":"2019/05/18/learn-ts7/","link":"","permalink":"https://blog.xiaoz.site/2019/05/18/learn-ts7/","excerpt":"交叉类型将多个类型合并为一个类型，Man &amp; Student 说明这个类型同时拥有 Man 和 Student 类型的成员 123456789101112type Man = &#123; name: string;&#125;;type Student = &#123; grade: number;&#125;;type Jack = Man &amp; Student;let jack: Jack = &#123; name: 'jack', grade: 5 // 如果缺少其中一个成员会报错&#125;; 有时候交叉类型不能交叉一些基本类型，如 string &amp; boolean 一个值不可能既是 string 也是 boolean，会被推断成 never 或只能赋值为 undefined 或 null","text":"交叉类型将多个类型合并为一个类型，Man &amp; Student 说明这个类型同时拥有 Man 和 Student 类型的成员 123456789101112type Man = &#123; name: string;&#125;;type Student = &#123; grade: number;&#125;;type Jack = Man &amp; Student;let jack: Jack = &#123; name: 'jack', grade: 5 // 如果缺少其中一个成员会报错&#125;; 有时候交叉类型不能交叉一些基本类型，如 string &amp; boolean 一个值不可能既是 string 也是 boolean，会被推断成 never 或只能赋值为 undefined 或 null 联合类型当一个值可能是多种不同类型时，使用联合类型 12345type strOrNum = string | number;let str: strOrNum = '';let num: strOrNum = 0;let bool: strOrNum = true; // error: Type 'true' is not assignable to type 'strOrNum' 当联合类型是函数返回值且成员是对象时，是求交集 1234567891011121314151617interface Bird &#123; fly(); layEggs();&#125;interface Fish &#123; swim(); layEggs();&#125;function getSmallPet(): Fish | Bird &#123; // ...&#125;let pet = getSmallPet();pet.layEggs(); // okaypet.swim(); // error 类型保护联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 Fish 或者是 Bird 时怎么办？ JavaScript 里常用来区分这 2 个可能值的方法是检查成员是否存在。如之前提及的，我们只能访问联合类型中共同拥有的成员。 12345678let pet = getSmallPet();// 每一个成员访问都会报错if (pet.swim) &#123; pet.swim();&#125; else if (pet.fly) &#123; pet.fly();&#125; 为了让这段代码工作，我们要使用类型断言： 1234567let pet = getSmallPet();if ((pet as Fish).swim) &#123; (pet as Fish).swim();&#125; else &#123; (pet as Bird).fly();&#125; 用户自定义的类型保护这里可以注意到我们不得不多次使用类型断言。如果我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet 的类型的话就好了。 TypeScript 里的类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个类型谓词： 123function isFish(pet: Fish | Bird): pet is Fish &#123; return (pet as Fish).swim !== undefined;&#125; 在这个例子里，pet is Fish 就是类型谓词。谓词为 parameterName is Type 这种形式， parameterName 必须是来自于当前函数签名里的一个参数名。 每当使用一些变量调用 isFish 时，TypeScript 会将变量缩减为那个具体的类型。 12345if (isFish(pet)) &#123; pet.swim();&#125; else &#123; pet.fly();&#125; 注意 TypeScript 不仅知道在 if 分支里 pet 是 Fish 类型；它还清楚在 else 分支里，一定不是 Fish 类型而是 Bird 类型。 typeof 类型保护现在我们回过头来看看怎么使用联合类型书写 padLeft 代码。我们可以像下面这样利用类型断言来写： 1234567891011121314151617function isNumber(x: any): x is string &#123; return typeof x === 'number';&#125;function isString(x: any): x is string &#123; return typeof x === 'string';&#125;function padLeft(value: string, padding: string | number) &#123; if (isNumber(padding)) &#123; return Array(padding + 1).join(' ') + value; &#125; if (isString(padding)) &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 然而，你必须要定义一个函数来判断类型是否是原始类型，但这并不必要。其实我们不必将 typeof x === &#39;number&#39;抽象成一个函数，因为 TypeScript 可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。 123456789function padLeft(value: string, padding: string | number) &#123; if (typeof padding === 'number') &#123; return Array(padding + 1).join(' ') + value; &#125; if (typeof padding === 'string') &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 这些 typeof 类型保护只有两种形式能被识别：typeof v === &quot;typename&quot; 和 typeof v !== &quot;typename&quot;， &quot;typename&quot;必须是 &quot;number&quot;， &quot;string&quot;，&quot;boolean&quot; 或 &quot;symbol&quot;。 但是 TypeScript 并不会阻止你与其它字符串比较，只是 TypeScript 不会把那些表达式识别为类型保护。 instanceof 类型保护如果你已经阅读了 typeof 类型保护并且对 JavaScript 里的 instanceof 操作符熟悉的话，你可能已经猜到了这节要讲的内容。 instanceof 类型保护是通过构造函数来细化类型的一种方式。我们把之前的例子做一个小小的改造： 1234567891011121314151617181920212223242526272829303132class Bird &#123; fly() &#123; console.log('bird fly'); &#125; layEggs() &#123; console.log('bird lay eggs'); &#125;&#125;class Fish &#123; swim() &#123; console.log('fish swim'); &#125; layEggs() &#123; console.log('fish lay eggs'); &#125;&#125;function getRandomPet() &#123; return Math.random() &gt; 0.5 ? new Bird() : new Fish();&#125;let pet = getRandomPet();if (pet instanceof Bird) &#123; pet.fly();&#125;if (pet instanceof Fish) &#123; pet.swim();&#125; 可以为 null 的类型TypeScript 具有两种特殊的类型，null 和 undefined，它们分别具有值 null 和 undefined。 默认情况下，类型检查器认为 null 与 undefined 可以赋值给任何类型。 null 与 undefined 是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。null的发明者，Tony Hoare，称它为价值亿万美金的错误。 --strictNullChecks 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 null 或 undefined。 你可以使用联合类型明确的包含它们： 123456let s = 'foo';s = null; // 错误, 'null'不能赋值给'string'let sn: string | null = 'bar';sn = null; // 可以sn = undefined; // error, 'undefined'不能赋值给'string | null' 注意，按照 JavaScript 的语义，TypeScript 会把 null 和 undefined 区别对待。string | null，string | undefined 和 string | undefined | null 是不同的类型。 可选参数和可选属性使用了 --strictNullChecks，可选参数会被自动地加上 | undefined: 1234567function f(x: number, y?: number) &#123; return x + (y || 0);&#125;f(1, 2);f(1);f(1, undefined);f(1, null); // error, 'null' 不能赋值给 'number | undefined' 可选属性也会有同样的处理： 12345678910class C &#123; a: number; b?: number;&#125;let c = new C();c.a = 12;c.a = undefined; // error, 'undefined' 不能赋值给 'number'c.b = 13;c.b = undefined; // okc.b = null; // error, 'null' 不能赋值给 'number | undefined' 类型保护和类型断言由于可以为 null 的类型能和其它类型定义为联合类型，那么你需要使用类型保护来去除 null。幸运地是这与在 JavaScript 里写的代码一致： 1234567function f(sn: string | null): string &#123; if (sn === null) &#123; return 'default'; &#125; else &#123; return sn; &#125;&#125; 这里很明显地去除了 null，你也可以使用短路运算符： 123function f(sn: string | null): string &#123; return sn || 'default';&#125; 如果编译器不能够去除 null 或 undefined，你可以使用类型断言手动去除。语法是添加 ! 后缀： identifier! 从 identifier 的类型里去除了 null 和 undefined： 1234567891011121314151617function broken(name: string | null): string &#123; function postfix(epithet: string) &#123; return name.charAt(0) + '. the ' + epithet; // error, 'name' 可能为 null &#125; name = name || 'Bob'; return postfix('great');&#125;function fixed(name: string | null): string &#123; function postfix(epithet: string) &#123; return name!.charAt(0) + '. the ' + epithet; // ok &#125; name = name || 'Bob'; return postfix('great');&#125;broken(null); 本例使用了嵌套函数，因为编译器无法去除嵌套函数的 null（除非是立即调用的函数表达式）。因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时 name 的类型。 字符串字面量类型字符串字面量类型允许你指定字符串必须具有的确切值。在实际应用中，字符串字面量类型可以与联合类型，类型保护很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。 1234567891011121314151617type Easing = 'ease-in' | 'ease-out' | 'ease-in-out';class UIElement &#123; animate(dx: number, dy: number, easing: Easing) &#123; if (easing === 'ease-in') &#123; // ... &#125; else if (easing === 'ease-out') &#123; &#125; else if (easing === 'ease-in-out') &#123; &#125; else &#123; // error! 不能传入 null 或者 undefined. &#125; &#125;&#125;let button = new UIElement();button.animate(0, 0, 'ease-in');button.animate(0, 0, 'uneasy'); // error: Argument of type '\"uneasy\"' is not assignable to parameter of type '\"ease-in\" | \"ease-out\" | \"ease-in-out\"' 你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。 总结基础 ts 学习完成了，其实基本上是把慕课网的教程一段一段复制过来的，不过也是为了加深自己的印象，简单问题可以直接看此笔记，如果要查漏补缺还是官网文档靠谱 参考ts 中文文档ts 官方文档","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"typescript","slug":"学习笔记/typescript","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://blog.xiaoz.site/tags/typescript/"}]},{"title":"typescript学习(6) 类型推断","slug":"learn-ts6","date":"2019-05-18T13:46:27.000Z","updated":"2019-09-06T06:15:25.723Z","comments":true,"path":"2019/05/18/learn-ts6/","link":"","permalink":"https://blog.xiaoz.site/2019/05/18/learn-ts6/","excerpt":"基础TypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子： 1let x = 3; 变量 x 的类型被推断为 number 。这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。 最佳通用类型有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如， 1let x = [0, 1, null]; 为了推断 x 的类型，我们必须考虑所有元素的类型。 这里有两种选择：number 和 null。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。 由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如：","text":"基础TypeScript 里，在有些没有明确指出类型的地方，类型推断会帮助提供类型。如下面的例子： 1let x = 3; 变量 x 的类型被推断为 number 。这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。 最佳通用类型有些时候我们需要从几个表达式中推断类型，会使用这些表达式的类型来推断出一个最合适的通用类型。例如， 1let x = [0, 1, null]; 为了推断 x 的类型，我们必须考虑所有元素的类型。 这里有两种选择：number 和 null。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。 由于最终的通用类型取自候选类型，有些时候候选类型共享一个公共结构，但是却没有一个类型能做为所有候选类型的超级类型。例如： 123456789class Animal &#123; numLegs: number;&#125;class Bee extends Animal &#123;&#125;class Lion extends Animal &#123;&#125;let zoo = [new Bee(), new Lion()]; 这里，我们想让 zoo 被推断为 Animal[] 类型，但是这个数组里没有对象是 Animal 类型的，因此不能推断出这个结果。 为了更正，我们可以明确的声明我们期望的类型： 1let zoo: Animal[] = [new Bee(), new Lion()]; 如果没有找到最佳通用类型的话，类型推断的结果为联合数组类型，(Bee | Lion)[] 上下文类型有些时候，TypeScript 类型推断会按另外一种方式，我们称作“上下文类型”；上下文类型的出现和表达式的类型以及所处的位置相关。比如： 123window.onmousedown = function(mouseEvent) &#123; console.log(mouseEvent.clickTime); // Error&#125;; 这个例子会得到一个类型错误，TypeScript 类型检查器使用 window.onmousedown 函数的类型来推断右边函数表达式的类型。 因此，就能推断出 mouseEvent 参数的类型了，所以 mouseEvent 访问了一个不存在的属性，就报错了。 如果上下文类型表达式包含了明确的类型信息，上下文的类型被忽略。重写上面的例子： 123window.onmousedown = function(mouseEvent: any) &#123; console.log(mouseEvent.clickTime); // OK&#125;; 这个函数表达式有明确的参数类型注解，上下文类型被忽略。这样的话就不报错了，因为这里不会使用到上下文类型。 上下文类型会在很多情况下使用到。通常包含函数的参数，赋值表达式的右边，类型断言，对象成员，数组字面量和返回值语句。上下文类型也会做为最佳通用类型的候选类型。比如： 12345function createZoo(): Animal[] &#123; return [new Bee(), new Lion()];&#125;let zoo = createZoo(); 这个例子里，最佳通用类型有 3 个候选者：Animal，Bee 和 Lion。 其中，Animal 会被做为最佳通用类型。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"typescript","slug":"学习笔记/typescript","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://blog.xiaoz.site/tags/typescript/"}]},{"title":"WSL 通过SSH登录","slug":"wslssh","date":"2019-05-17T05:24:40.000Z","updated":"2019-09-06T06:15:25.725Z","comments":true,"path":"2019/05/17/wslssh/","link":"","permalink":"https://blog.xiaoz.site/2019/05/17/wslssh/","excerpt":"配置ssh server自带的ssh server不好用（好不好用不知道，反正网上的教程都是这么说的），先卸载再安装即可。 12345678910111213// 卸载sudo apt-get remove openssh-server// 安装sudo apt-get install openssh-server// 编辑配置文件// vim /etc/ssh/sshd_config Port 22222 # 默认的是22，但是windows有自己的ssh服务用的也是22端口，修改一下 PubkeyAuthentication yes PermitRootLogin prohibit-password// 重启ssh服务sudo service ssh --full-restart 生成公钥秘钥xshell &gt; 工具 &gt; 新建用户秘钥生成向导 &gt; 下一步，具体如图。 第一步","text":"配置ssh server自带的ssh server不好用（好不好用不知道，反正网上的教程都是这么说的），先卸载再安装即可。 12345678910111213// 卸载sudo apt-get remove openssh-server// 安装sudo apt-get install openssh-server// 编辑配置文件// vim /etc/ssh/sshd_config Port 22222 # 默认的是22，但是windows有自己的ssh服务用的也是22端口，修改一下 PubkeyAuthentication yes PermitRootLogin prohibit-password// 重启ssh服务sudo service ssh --full-restart 生成公钥秘钥xshell &gt; 工具 &gt; 新建用户秘钥生成向导 &gt; 下一步，具体如图。 第一步 第二步，默认即可 第三步，记住你的密码 第四步，生成密钥成功，这里展示的是公钥，点击保存为文件,，比如d:\\download\\key.pub 上传公钥到server目标地址是/root/.ssh/authorized_keys文件，没有则新建 1234cd /rootmkdir .sshmv /mnt/d/download/key.pub /root/.sshcat key.pub &gt; authorized_keys wsl可以直接访问到windows的文件，在 /mnt 目录下 设置文件权限这一步很重要，之前看的有些教程没有写这一步，导致一直连接不上 12chmod 600 authorized_keyschmod 700 ~/.ssh 重启ssh1sudo service ssh --full-restart xshell 连接ssh 第一步，填写主机和端口 第二步，设置验证方式，选择 Public Key，选择相应秘钥，输入之前设置的密码 第三步，点击连接，搞定 参考使用xshell登录ubuntu on windows(wsl) WSL 通过SSH登录","categories":[{"name":"learn","slug":"learn","permalink":"https://blog.xiaoz.site/categories/learn/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://blog.xiaoz.site/tags/tips/"}]},{"title":"eslint 禁用规则","slug":"doc/eslintDisable","date":"2019-05-17T01:52:35.000Z","updated":"2019-09-06T06:15:25.720Z","comments":true,"path":"2019/05/17/doc/eslintDisable/","link":"","permalink":"https://blog.xiaoz.site/2019/05/17/doc/eslintDisable/","excerpt":"块禁用123/* eslint-disable */alert('foo');/* eslint-enable */ 块指定的规则禁用123/* eslint-disable no-alert, no-console */alert('foo');console.log('bar');/* eslint-enable no-alert, no-console */","text":"块禁用123/* eslint-disable */alert('foo');/* eslint-enable */ 块指定的规则禁用123/* eslint-disable no-alert, no-console */alert('foo');console.log('bar');/* eslint-enable no-alert, no-console */ 整个文件禁用12/* eslint-disable */alert('foo'); 整个文件禁用指定的规则12/* eslint-disable no-alert */alert('foo'); 行注释123alert('foo'); // eslint-disable-line// eslint-disable-next-linealert('foo'); 行禁用禁用指定的规则123alert('foo'); // eslint-disable-line no-alert, quotes, semi// eslint-disable-next-line no-alert, quotes, semialert('foo'); 禁用插件规则1foo(123); // eslint-disable-line 插件名/规则名","categories":[{"name":"work","slug":"work","permalink":"https://blog.xiaoz.site/categories/work/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://blog.xiaoz.site/tags/tips/"}]},{"title":"typescript学习(5) 泛型","slug":"learn-ts5","date":"2019-05-16T13:56:03.000Z","updated":"2019-09-06T06:15:25.722Z","comments":true,"path":"2019/05/16/learn-ts5/","link":"","permalink":"https://blog.xiaoz.site/2019/05/16/learn-ts5/","excerpt":"泛型为定义提供了重用性，在创建大型系统时为你提供了十分灵活的功能 基础实例创建一个 identity 函数，它会返回任何传入值，如果不用泛型 123function identity(arg: any): any &#123; return arg;&#125; 但是使用 any 会导致 ts 不提供类型检查，我们需要知道传入类型和返回类型是相同的，所以需要使用泛型，泛型是一种 类型变量 ，它值用于表示类型而不是值 123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;","text":"泛型为定义提供了重用性，在创建大型系统时为你提供了十分灵活的功能 基础实例创建一个 identity 函数，它会返回任何传入值，如果不用泛型 123function identity(arg: any): any &#123; return arg;&#125; 但是使用 any 会导致 ts 不提供类型检查，我们需要知道传入类型和返回类型是相同的，所以需要使用泛型，泛型是一种 类型变量 ，它值用于表示类型而不是值 123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 我们给 identity 添加了类型变量 T。 T 帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了 T 当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。这允许我们跟踪函数里使用的类型的信息。 定义了泛型之后，有两种方法使用 12let output = identity&lt;string&gt;('myString');let output1 = identity('myString'); 第一种明确制定了 T 是 string 类型，并作为一个参数传给函数第二种利用了 类型推论 ，ts 会根据参数自动确定 T 的类型一般同第二种就好了，当 ts 无法推断时，用第一种 泛型变量泛型变量可以当做类型的一部分使用 1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // error: Property 'length' does not exist on type 'T'. return arg;&#125; 类型变量 T 代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 .length 属性的，ts 会报错 1234function loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); return arg;&#125; 用以上方式写，参数 arg 是一个数组，所以有 length 属性，此时 T 表示数组元素的类型 泛型类型函数1234function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity; 可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。 泛型接口1234567891011interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;// 编辑器会建议修改为类型别名的写法// type GenericIdentityFn = &lt;T&gt;(arg: T) =&gt; Tfunction identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn = identity; 我们还可以把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： Dictionary&lt;string&gt; 而不只是 Dictionary ）。这样接口里的其它成员也能知道这个参数的类型了 1234567891011interface GenericIdentityFn&lt;T&gt; &#123; (arg: T): T;&#125;// 编辑器会建议修改为：// type GenericIdentityFn&lt;T&gt; = (arg: T) =&gt; T;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity; 注意，我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 GenericIdentityFn 的时候，还得传入一个类型参数来指定泛型类型（这里是： number ），锁定了之后代码里使用的类型。对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的 泛型类泛型类看上去与泛型接口差不多。 泛型类使用 &lt;&gt; 括起泛型类型，跟在类名后面 12345678910class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y;&#125;; 与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。 类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型 泛型约束1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // error: Property 'length' does not exist on type 'T' return arg;&#125; 要修正上面的例子中的错误，可以使用到泛型约束 我们定义一个接口来描述约束条件，创建一个包含 .length 属性的接口，使用这个接口和 extends 关键字来实现约束 1234567891011interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // OK return arg;&#125;loggingIdentity(3); // ErrorloggingIdentity(&#123; length: 10, value: 3 &#125;); // OK 我们需要传入符合约束类型的值，必须包含必须的属性 在泛型约束中使用类型参数你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj 上，因此我们需要在这两个类型之间使用约束。 12345678function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K) &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;getProperty(x, 'a'); // okaygetProperty(x, 'm'); // error","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"typescript","slug":"学习笔记/typescript","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://blog.xiaoz.site/tags/typescript/"}]},{"title":"React & Redux in TypeScript","slug":"doc/ReactReduxInTypeScript","date":"2019-05-16T03:34:58.000Z","updated":"2020-07-29T03:23:50.398Z","comments":true,"path":"2019/05/16/doc/ReactReduxInTypeScript/","link":"","permalink":"https://blog.xiaoz.site/2019/05/16/doc/ReactReduxInTypeScript/","excerpt":"React &amp; Redux 配合 TypeScript 使用指南，想翻译来着，今年年底前一定给他弄了💪","text":"React &amp; Redux 配合 TypeScript 使用指南，想翻译来着，今年年底前一定给他弄了💪 React &amp; Redux in TypeScript - Complete Guide“This guide is a living compendium documenting the most important patterns and recipes on how to use React (and its Ecosystem) in a functional style using TypeScript. It will help you make your code completely type-safe while focusing on inferring the types from implementation so there is less noise coming from excessive type annotations and it’s easier to write and maintain correct types in the long run.” Found it useful? Want more updates? Show your support by giving a :star: What’s new?:tada: Now updated to support TypeScript v3.7 :tada::rocket: _Updated to typesafe-actions@5.x.x :rocket: Goals Complete type safety (with --strict flag) without losing type information downstream through all the layers of our application (e.g. no type assertions or hacking with any type) Make type annotations concise by eliminating redundancy in types using advanced TypeScript Language features like Type Inference and Control flow analysis Reduce repetition and complexity of types with TypeScript focused complementary libraries React, Redux, Typescript Ecosystem typesafe-actions - Typesafe utilities for “action-creators” in Redux / Flux Architecture utility-types - Collection of generic types for TypeScript, complementing built-in mapped types and aliases - think lodash for reusable types. react-redux-typescript-scripts - dev-tools configuration files shared between projects based on this guide Examples Todo-App playground: Codesandbox React, Redux, TypeScript - RealWorld App: Github | Demo Playground Project Check out our Playground Project located in the /playground folder. It contains all source files of the code examples found in the guide. They are all tested with the most recent version of TypeScript and 3rd party type-definitions (like @types/react or @types/react-redux) to ensure the examples are up-to-date and not broken with updated definitions (It’s based on create-react-app --typescript). Playground project was created so that you can simply clone the repository locally and immediately play around with all the component patterns found in the guide. It will help you to learn all the examples from this guide in a real project environment without the need to create complicated environment setup by yourself. Contributing GuideYou can help make this project better by contributing. If you’re planning to contribute please make sure to check our contributing guide: CONTRIBUTING.md FundingYou can also help by funding issues.Issues like bug fixes or feature requests can be very quickly resolved when funded through the IssueHunt platform. I highly recommend to add a bounty to the issue that you’re waiting for to increase priority and attract contributors willing to work on it. 🌟 - New or updated section Table of Contents React - Type-Definitions Cheatsheet React.FC&lt;Props&gt; | React.FunctionComponent&lt;Props&gt; React.Component&lt;Props, State&gt; React.ComponentType&lt;Props&gt; React.ComponentProps&lt;typeof XXX&gt; React.ReactElement | JSX.Element React.ReactNode React.CSSProperties React.HTMLProps&lt;HTMLXXXElement&gt; React.ReactEventHandler&lt;HTMLXXXElement&gt; React.XXXEvent&lt;HTMLXXXElement&gt; React - Typing Patterns Function Components - FC - Counter Component - Spreading attributes in Component Class Components - Class Counter Component - Class Component with default props Generic Components - Generic List Component Render Props - Name Provider Component - Mouse Provider Component Higher-Order Components - HOC wrapping a component - HOC wrapping a component and injecting props - Nested HOC - wrapping a component, injecting props and connecting to redux 🌟 Redux Connected Components - Redux connected counter - Redux connected counter with own props - Redux connected counter with redux-thunk integration Context ThemeContext ThemeProvider ThemeConsumer ThemeConsumer in class component Hooks - useState - useReducer - useContext Redux - Typing Patterns Store Configuration Create Global Store Types Create Store Action Creators 🌟 Reducers State with Type-level Immutability Typing reducer Typing reducer with typesafe-actions Testing reducer Async Flow with redux-observable Typing epics Testing epics Selectors with reselect Connect with react-redux Typing connected component Typing connected component with redux-thunk integration Configuration &amp; Dev Tools Common Npm Scripts tsconfig.json TSLib TSLint ESLint Jest Style Guides “react-styleguidist” Recipes General Tips Ambient Modules Tips Type-Definitions Tips Type Augmentation Tips Tutorials &amp; Articles Contributors InstallationType-Definitions for React &amp; Redux1npm i -D @types&#x2F;react @types&#x2F;react-dom @types&#x2F;react-redux “react” - @types/react“react-dom” - @types/react-dom“redux” - (types included with npm package)*“react-redux” - @types/react-redux *NB: Guide is based on types for Redux &gt;= v4.x.x. To make it work with Redux v3.x.x please refer to this config) ⇧ back to top React - Type-Definitions CheatsheetReact.FC&lt;Props&gt; | React.FunctionComponent&lt;Props&gt;Type representing a functional component 1const MyComponent: React.FC&lt;Props&gt; &#x3D; ... React.Component&lt;Props, State&gt;Type representing a class component 1class MyComponent extends React.Component&lt;Props, State&gt; &#123; ... React.ComponentType&lt;Props&gt;Type representing union of (React.FC | React.Component) - used in HOC 123const withState &#x3D; &lt;P extends WrappedComponentProps&gt;( WrappedComponent: React.ComponentType&lt;P&gt;,) &#x3D;&gt; &#123; ... React.ComponentProps&lt;typeof XXX&gt;Gets Props type of a specified component XXX (WARNING: does not work with statically declared default props and generic props) 1type MyComponentProps &#x3D; React.ComponentProps&lt;typeof MyComponent&gt;; React.ReactElement | JSX.ElementType representing a concept of React Element - representation of a native DOM component (e.g. &lt;div /&gt;), or a user-defined composite component (e.g. &lt;MyComponent /&gt;) 1const elementOnly: React.ReactElement &#x3D; &lt;div &#x2F;&gt; || &lt;MyComponent &#x2F;&gt;; React.ReactNodeType representing any possible type of React node (basically ReactElement (including Fragments and Portals) + primitive JS types) 12const elementOrPrimitive: React.ReactNode &#x3D; &#39;string&#39; || 0 || false || null || undefined || &lt;div &#x2F;&gt; || &lt;MyComponent &#x2F;&gt;;const Component &#x3D; (&#123; children: React.ReactNode &#125;) &#x3D;&gt; ... React.CSSPropertiesType representing style object in JSX - for css-in-js styles 12const styles: React.CSSProperties &#x3D; &#123; flexDirection: &#39;row&#39;, ...const element &#x3D; &lt;div style&#x3D;&#123;styles&#125; ... React.HTMLProps&lt;HTMLXXXElement&gt;Type representing Props of specified HTML Element - for extending HTML Elements 123const Input: React.FC&lt;Props &amp; React.HTMLProps&lt;HTMLInputElement&gt;&gt; &#x3D; props &#x3D;&gt; &#123; ... &#125;&lt;Input about&#x3D;&#123;...&#125; accept&#x3D;&#123;...&#125; alt&#x3D;&#123;...&#125; ... &#x2F;&gt; React.ReactEventHandler&lt;HTMLXXXElement&gt;Type representing generic event handler - for declaring event handlers 123const handleChange: React.ReactEventHandler&lt;HTMLInputElement&gt; &#x3D; (ev) &#x3D;&gt; &#123; ... &#125;&lt;input onChange&#x3D;&#123;handleChange&#125; ... &#x2F;&gt; React.XXXEvent&lt;HTMLXXXElement&gt;Type representing more specific event. Some common event examples: ChangeEvent, FormEvent, FocusEvent, KeyboardEvent, MouseEvent, DragEvent, PointerEvent, WheelEvent, TouchEvent. 123const handleChange &#x3D; (ev: React.MouseEvent&lt;HTMLDivElement&gt;) &#x3D;&gt; &#123; ... &#125;&lt;div onMouseMove&#x3D;&#123;handleChange&#125; ... &#x2F;&gt; In code above React.MouseEvent&lt;HTMLDivElement&gt; is type of mouse event, and this event happened on HTMLDivElement ⇧ back to top React - Typing PatternsFunction Components - FC- Counter Component1234567891011121314151617181920212223242526import * as React from &quot;react&quot;;type Props &#x3D; &#123; label: string; count: number; onIncrement: () &#x3D;&gt; void;&#125;;export const FCCounter: React.FC&lt;Props&gt; &#x3D; (props) &#x3D;&gt; &#123; const &#123; label, count, onIncrement &#125; &#x3D; props; const handleIncrement &#x3D; () &#x3D;&gt; &#123; onIncrement(); &#125;; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;: &#123;count&#125; &lt;&#x2F;span&gt; &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;handleIncrement&#125;&gt; &#123;&#96;Increment&#96;&#125; &lt;&#x2F;button&gt; &lt;&#x2F;div&gt; );&#125;; ⟩⟩⟩ demo ⇧ back to top - Spreading attributes in Component123456789101112import * as React from &quot;react&quot;;type Props &#x3D; &#123; className?: string; style?: React.CSSProperties;&#125;;export const FCSpreadAttributes: React.FC&lt;Props&gt; &#x3D; (props) &#x3D;&gt; &#123; const &#123; children, ...restProps &#125; &#x3D; props; return &lt;div &#123;...restProps&#125;&gt;&#123;children&#125;&lt;&#x2F;div&gt;;&#125;; ⟩⟩⟩ demo ⇧ back to top Class Components- Class Counter Component123456789101112131415161718192021222324252627282930313233343536import * as React from &quot;react&quot;;type Props &#x3D; &#123; label: string;&#125;;type State &#x3D; &#123; count: number;&#125;;export class ClassCounter extends React.Component&lt;Props, State&gt; &#123; readonly state: State &#x3D; &#123; count: 0, &#125;; handleIncrement &#x3D; () &#x3D;&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125;; render() &#123; const &#123; handleIncrement &#125; &#x3D; this; const &#123; label &#125; &#x3D; this.props; const &#123; count &#125; &#x3D; this.state; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;: &#123;count&#125; &lt;&#x2F;span&gt; &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;handleIncrement&#125;&gt; &#123;&#96;Increment&#96;&#125; &lt;&#x2F;button&gt; &lt;&#x2F;div&gt; ); &#125;&#125; ⟩⟩⟩ demo ⇧ back to top - Class Component with default props1234567891011121314151617181920212223242526272829303132333435363738394041424344import * as React from &quot;react&quot;;type Props &#x3D; &#123; label: string; initialCount: number;&#125;;type State &#x3D; &#123; count: number;&#125;;export class ClassCounterWithDefaultProps extends React.Component&lt; Props, State&gt; &#123; static defaultProps &#x3D; &#123; initialCount: 0, &#125;; readonly state: State &#x3D; &#123; count: this.props.initialCount, &#125;; handleIncrement &#x3D; () &#x3D;&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125;; render() &#123; const &#123; handleIncrement &#125; &#x3D; this; const &#123; label &#125; &#x3D; this.props; const &#123; count &#125; &#x3D; this.state; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;: &#123;count&#125; &lt;&#x2F;span&gt; &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;handleIncrement&#125;&gt; &#123;&#96;Increment&#96;&#125; &lt;&#x2F;button&gt; &lt;&#x2F;div&gt; ); &#125;&#125; ⟩⟩⟩ demo ⇧ back to top Generic Components easily create typed component variations and reuse common logic common use case is a generic list components - Generic List Component1234567891011121314import * as React from &quot;react&quot;;export interface GenericListProps&lt;T&gt; &#123; items: T[]; itemRenderer: (item: T) &#x3D;&gt; JSX.Element;&#125;export class GenericList&lt;T&gt; extends React.Component&lt;GenericListProps&lt;T&gt;, &#123;&#125;&gt; &#123; render() &#123; const &#123; items, itemRenderer &#125; &#x3D; this.props; return &lt;div&gt;&#123;items.map(itemRenderer)&#125;&lt;&#x2F;div&gt;; &#125;&#125; ⟩⟩⟩ demo ⇧ back to top Render Props https://reactjs.org/docs/render-props.html - Name Provider Component simple component using children as a render prop 1234567891011121314151617181920import * as React from &quot;react&quot;;interface NameProviderProps &#123; children: (state: NameProviderState) &#x3D;&gt; React.ReactNode;&#125;interface NameProviderState &#123; readonly name: string;&#125;export class NameProvider extends React.Component&lt; NameProviderProps, NameProviderState&gt; &#123; readonly state: NameProviderState &#x3D; &#123; name: &quot;Piotr&quot; &#125;; render() &#123; return this.props.children(this.state); &#125;&#125; ⟩⟩⟩ demo ⇧ back to top - Mouse Provider Component Mouse component found in Render Props React Docs 123456789101112131415161718192021222324252627282930313233343536import * as React from &quot;react&quot;;export interface MouseProviderProps &#123; render: (state: MouseProviderState) &#x3D;&gt; React.ReactNode;&#125;interface MouseProviderState &#123; readonly x: number; readonly y: number;&#125;export class MouseProvider extends React.Component&lt; MouseProviderProps, MouseProviderState&gt; &#123; readonly state: MouseProviderState &#x3D; &#123; x: 0, y: 0 &#125;; handleMouseMove &#x3D; (event: React.MouseEvent&lt;HTMLDivElement&gt;) &#x3D;&gt; &#123; this.setState(&#123; x: event.clientX, y: event.clientY, &#125;); &#125;; render() &#123; return ( &lt;div style&#x3D;&#123;&#123; height: &quot;100%&quot; &#125;&#125; onMouseMove&#x3D;&#123;this.handleMouseMove&#125;&gt; &#123;&#x2F;* Instead of providing a static representation of what &lt;Mouse&gt; renders, use the &#96;render&#96; prop to dynamically determine what to render. *&#x2F;&#125; &#123;this.props.render(this.state)&#125; &lt;&#x2F;div&gt; ); &#125;&#125; ⟩⟩⟩ demo ⇧ back to top Higher-Order Components https://reactjs.org/docs/higher-order-components.html - HOC wrapping a componentAdds state to a stateless counter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React from &quot;react&quot;;import &#123; Diff &#125; from &quot;utility-types&quot;;&#x2F;&#x2F; These props will be injected into the base componentinterface InjectedProps &#123; count: number; onIncrement: () &#x3D;&gt; void;&#125;export const withState &#x3D; &lt;BaseProps extends InjectedProps&gt;( BaseComponent: React.ComponentType&lt;BaseProps&gt;) &#x3D;&gt; &#123; type HocProps &#x3D; Diff&lt;BaseProps, InjectedProps&gt; &amp; &#123; &#x2F;&#x2F; here you can extend hoc with new props initialCount?: number; &#125;; type HocState &#x3D; &#123; readonly count: number; &#125;; return class Hoc extends React.Component&lt;HocProps, HocState&gt; &#123; &#x2F;&#x2F; Enhance component name for debugging and React-Dev-Tools static displayName &#x3D; &#96;withState($&#123;BaseComponent.name&#125;)&#96;; &#x2F;&#x2F; reference to original wrapped component static readonly WrappedComponent &#x3D; BaseComponent; readonly state: HocState &#x3D; &#123; count: Number(this.props.initialCount) || 0, &#125;; handleIncrement &#x3D; () &#x3D;&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125;; render() &#123; const &#123; ...restProps &#125; &#x3D; this.props; const &#123; count &#125; &#x3D; this.state; return ( &lt;BaseComponent count&#x3D;&#123;count&#125; &#x2F;&#x2F; injected onIncrement&#x3D;&#123;this.handleIncrement&#125; &#x2F;&#x2F; injected &#123;...(restProps as BaseProps)&#125; &#x2F;&gt; ); &#125; &#125;;&#125;; Click to expand 12345678import * as React from &quot;react&quot;;import &#123; withState &#125; from &quot;..&#x2F;hoc&quot;;import &#123; FCCounter &#125; from &quot;..&#x2F;components&quot;;const FCCounterWithState &#x3D; withState(FCCounter);export default () &#x3D;&gt; &lt;FCCounterWithState label&#x3D;&#123;&quot;FCCounterWithState&quot;&#125; &#x2F;&gt;; ⇧ back to top - HOC wrapping a component and injecting propsAdds error handling using componentDidCatch to any component 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React from &quot;react&quot;;const MISSING_ERROR &#x3D; &quot;Error was swallowed during propagation.&quot;;export const withErrorBoundary &#x3D; &lt;BaseProps extends &#123;&#125;&gt;( BaseComponent: React.ComponentType&lt;BaseProps&gt;) &#x3D;&gt; &#123; type HocProps &#x3D; &#123; &#x2F;&#x2F; here you can extend hoc with new props &#125;; type HocState &#x3D; &#123; readonly error: Error | null | undefined; &#125;; return class Hoc extends React.Component&lt;HocProps, HocState&gt; &#123; &#x2F;&#x2F; Enhance component name for debugging and React-Dev-Tools static displayName &#x3D; &#96;withErrorBoundary($&#123;BaseComponent.name&#125;)&#96;; &#x2F;&#x2F; reference to original wrapped component static readonly WrappedComponent &#x3D; BaseComponent; readonly state: HocState &#x3D; &#123; error: undefined, &#125;; componentDidCatch(error: Error | null, info: object) &#123; this.setState(&#123; error: error || new Error(MISSING_ERROR) &#125;); this.logErrorToCloud(error, info); &#125; logErrorToCloud &#x3D; (error: Error | null, info: object) &#x3D;&gt; &#123; &#x2F;&#x2F; TODO: send error report to service provider &#125;; render() &#123; const &#123; children, ...restProps &#125; &#x3D; this.props; const &#123; error &#125; &#x3D; this.state; if (error) &#123; return &lt;BaseComponent &#123;...(restProps as BaseProps)&#125; &#x2F;&gt;; &#125; return children; &#125; &#125;;&#125;; Click to expand 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; useState &#125; from &quot;react&quot;;import &#123; withErrorBoundary &#125; from &quot;..&#x2F;hoc&quot;;import &#123; ErrorMessage &#125; from &quot;..&#x2F;components&quot;;const ErrorMessageWithErrorBoundary &#x3D; withErrorBoundary(ErrorMessage);const BrokenComponent &#x3D; () &#x3D;&gt; &#123; throw new Error(&quot;I&#39;m broken! Don&#39;t render me.&quot;);&#125;;const BrokenButton &#x3D; () &#x3D;&gt; &#123; const [ shouldRenderBrokenComponent, setShouldRenderBrokenComponent, ] &#x3D; useState(false); if (shouldRenderBrokenComponent) &#123; return &lt;BrokenComponent &#x2F;&gt;; &#125; return ( &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;() &#x3D;&gt; &#123; setShouldRenderBrokenComponent(true); &#125;&#125; &gt; &#123;&#96;Throw nasty error&#96;&#125; &lt;&#x2F;button&gt; );&#125;;export default () &#x3D;&gt; ( &lt;ErrorMessageWithErrorBoundary&gt; &lt;BrokenButton &#x2F;&gt; &lt;&#x2F;ErrorMessageWithErrorBoundary&gt;); ⇧ back to top - Nested HOC - wrapping a component, injecting props and connecting to redux 🌟Adds error handling using componentDidCatch to any component 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import &#123; RootState &#125; from &quot;MyTypes&quot;;import React from &quot;react&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; Diff &#125; from &quot;utility-types&quot;;import &#123; countersActions, countersSelectors &#125; from &quot;..&#x2F;features&#x2F;counters&quot;;&#x2F;&#x2F; These props will be injected into the base componentinterface InjectedProps &#123; count: number; onIncrement: () &#x3D;&gt; void;&#125;export const withConnectedCount &#x3D; &lt;BaseProps extends InjectedProps&gt;( BaseComponent: React.ComponentType&lt;BaseProps&gt;) &#x3D;&gt; &#123; const mapStateToProps &#x3D; (state: RootState) &#x3D;&gt; (&#123; count: countersSelectors.getReduxCounter(state.counters), &#125;); const dispatchProps &#x3D; &#123; onIncrement: countersActions.increment, &#125;; type HocProps &#x3D; ReturnType&lt;typeof mapStateToProps&gt; &amp; typeof dispatchProps &amp; &#123; &#x2F;&#x2F; here you can extend ConnectedHoc with new props overrideCount?: number; &#125;; class Hoc extends React.Component&lt;HocProps&gt; &#123; &#x2F;&#x2F; Enhance component name for debugging and React-Dev-Tools static displayName &#x3D; &#96;withConnectedCount($&#123;BaseComponent.name&#125;)&#96;; &#x2F;&#x2F; reference to original wrapped component static readonly WrappedComponent &#x3D; BaseComponent; render() &#123; const &#123; count, onIncrement, overrideCount, ...restProps &#125; &#x3D; this.props; return ( &lt;BaseComponent count&#x3D;&#123;overrideCount || count&#125; &#x2F;&#x2F; injected onIncrement&#x3D;&#123;onIncrement&#125; &#x2F;&#x2F; injected &#123;...(restProps as BaseProps)&#125; &#x2F;&gt; ); &#125; &#125; const ConnectedHoc &#x3D; connect&lt; ReturnType&lt;typeof mapStateToProps&gt;, typeof dispatchProps, &#x2F;&#x2F; use &quot;undefined&quot; if NOT using dispatchProps Diff&lt;BaseProps, InjectedProps&gt;, RootState &gt;( mapStateToProps, dispatchProps )(Hoc); return ConnectedHoc;&#125;; Click to expand 12345678910import * as React from &quot;react&quot;;import &#123; withConnectedCount &#125; from &quot;..&#x2F;hoc&quot;;import &#123; FCCounter &#125; from &quot;..&#x2F;components&quot;;const FCCounterWithConnectedCount &#x3D; withConnectedCount(FCCounter);export default () &#x3D;&gt; ( &lt;FCCounterWithConnectedCount overrideCount&#x3D;&#123;5&#125; label&#x3D;&#123;&quot;FCCounterWithState&quot;&#125; &#x2F;&gt;); ⇧ back to top Redux Connected Components- Redux connected counter123456789101112131415161718import Types from &quot;MyTypes&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; countersActions, countersSelectors &#125; from &quot;..&#x2F;features&#x2F;counters&quot;;import &#123; FCCounter &#125; from &quot;..&#x2F;components&quot;;const mapStateToProps &#x3D; (state: Types.RootState) &#x3D;&gt; (&#123; count: countersSelectors.getReduxCounter(state.counters),&#125;);const dispatchProps &#x3D; &#123; onIncrement: countersActions.increment,&#125;;export const FCCounterConnected &#x3D; connect( mapStateToProps, dispatchProps)(FCCounter); Click to expand 12345import * as React from &quot;react&quot;;import &#123; FCCounterConnected &#125; from &quot;.&quot;;export default () &#x3D;&gt; &lt;FCCounterConnected label&#x3D;&#123;&quot;FCCounterConnected&quot;&#125; &#x2F;&gt;; ⇧ back to top - Redux connected counter with own props123456789101112131415161718192021222324import Types from &quot;MyTypes&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; countersActions, countersSelectors &#125; from &quot;..&#x2F;features&#x2F;counters&quot;;import &#123; FCCounter &#125; from &quot;..&#x2F;components&quot;;type OwnProps &#x3D; &#123; initialCount?: number;&#125;;const mapStateToProps &#x3D; (state: Types.RootState, ownProps: OwnProps) &#x3D;&gt; (&#123; count: countersSelectors.getReduxCounter(state.counters) + (ownProps.initialCount || 0),&#125;);const dispatchProps &#x3D; &#123; onIncrement: countersActions.increment,&#125;;export const FCCounterConnectedOwnProps &#x3D; connect( mapStateToProps, dispatchProps)(FCCounter); Click to expand 12345678910import * as React from &quot;react&quot;;import &#123; FCCounterConnectedOwnProps &#125; from &quot;.&quot;;export default () &#x3D;&gt; ( &lt;FCCounterConnectedOwnProps label&#x3D;&#123;&quot;FCCounterConnectedOwnProps&quot;&#125; initialCount&#x3D;&#123;10&#125; &#x2F;&gt;); ⇧ back to top - Redux connected counter with redux-thunk integration12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import Types from &quot;MyTypes&quot;;import &#123; bindActionCreators, Dispatch &#125; from &quot;redux&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import * as React from &quot;react&quot;;import &#123; countersActions &#125; from &quot;..&#x2F;features&#x2F;counters&quot;;&#x2F;&#x2F; Thunk Actionconst incrementWithDelay &#x3D; () &#x3D;&gt; async (dispatch: Dispatch): Promise&lt;void&gt; &#x3D;&gt; &#123; setTimeout(() &#x3D;&gt; dispatch(countersActions.increment()), 1000);&#125;;const mapStateToProps &#x3D; (state: Types.RootState) &#x3D;&gt; (&#123; count: state.counters.reduxCounter,&#125;);const mapDispatchToProps &#x3D; (dispatch: Dispatch&lt;Types.RootAction&gt;) &#x3D;&gt; bindActionCreators( &#123; onIncrement: incrementWithDelay, &#125;, dispatch );type Props &#x3D; ReturnType&lt;typeof mapStateToProps&gt; &amp; ReturnType&lt;typeof mapDispatchToProps&gt; &amp; &#123; label: string; &#125;;export const FCCounter: React.FC&lt;Props&gt; &#x3D; (props) &#x3D;&gt; &#123; const &#123; label, count, onIncrement &#125; &#x3D; props; const handleIncrement &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; Thunk action is correctly typed as promise onIncrement().then(() &#x3D;&gt; &#123; &#x2F;&#x2F; ... &#125;); &#125;; return ( &lt;div&gt; &lt;span&gt; &#123;label&#125;: &#123;count&#125; &lt;&#x2F;span&gt; &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;handleIncrement&#125;&gt; &#123;&#96;Increment&#96;&#125; &lt;&#x2F;button&gt; &lt;&#x2F;div&gt; );&#125;;export const FCCounterConnectedBindActionCreators &#x3D; connect( mapStateToProps, mapDispatchToProps)(FCCounter); Click to expand 123456789import * as React from &quot;react&quot;;import &#123; FCCounterConnectedBindActionCreators &#125; from &quot;.&quot;;export default () &#x3D;&gt; ( &lt;FCCounterConnectedBindActionCreators label&#x3D;&#123;&quot;FCCounterConnectedBindActionCreators&quot;&#125; &#x2F;&gt;); ⇧ back to top Context https://reactjs.org/docs/context.html ThemeContext1234567891011121314151617181920212223242526import * as React from &quot;react&quot;;export type Theme &#x3D; React.CSSProperties;type Themes &#x3D; &#123; dark: Theme; light: Theme;&#125;;export const themes: Themes &#x3D; &#123; dark: &#123; color: &quot;black&quot;, backgroundColor: &quot;white&quot;, &#125;, light: &#123; color: &quot;white&quot;, backgroundColor: &quot;black&quot;, &#125;,&#125;;export type ThemeContextProps &#x3D; &#123; theme: Theme; toggleTheme?: () &#x3D;&gt; void &#125;;const ThemeContext &#x3D; React.createContext&lt;ThemeContextProps&gt;(&#123; theme: themes.light,&#125;);export default ThemeContext; ⇧ back to top ThemeProvider1234567891011121314151617181920212223242526import React from &quot;react&quot;;import ThemeContext, &#123; themes, Theme &#125; from &quot;.&#x2F;theme-context&quot;;import ToggleThemeButton from &quot;.&#x2F;theme-consumer&quot;;interface State &#123; theme: Theme;&#125;export class ThemeProvider extends React.Component&lt;&#123;&#125;, State&gt; &#123; readonly state: State &#x3D; &#123; theme: themes.light &#125;; toggleTheme &#x3D; () &#x3D;&gt; &#123; this.setState((state) &#x3D;&gt; (&#123; theme: state.theme &#x3D;&#x3D;&#x3D; themes.light ? themes.dark : themes.light, &#125;)); &#125;; render() &#123; const &#123; theme &#125; &#x3D; this.state; const &#123; toggleTheme &#125; &#x3D; this; return ( &lt;ThemeContext.Provider value&#x3D;&#123;&#123; theme, toggleTheme &#125;&#125;&gt; &lt;ToggleThemeButton &#x2F;&gt; &lt;&#x2F;ThemeContext.Provider&gt; ); &#125;&#125; ⇧ back to top ThemeConsumer1234567891011121314import * as React from &quot;react&quot;;import ThemeContext from &quot;.&#x2F;theme-context&quot;;type Props &#x3D; &#123;&#125;;export default function ToggleThemeButton(props: Props) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;(&#123; theme, toggleTheme &#125;) &#x3D;&gt; ( &lt;button style&#x3D;&#123;theme&#125; onClick&#x3D;&#123;toggleTheme&#125; &#123;...props&#125; &#x2F;&gt; )&#125; &lt;&#x2F;ThemeContext.Consumer&gt; );&#125; ThemeConsumer in class component123456789101112131415161718import * as React from &quot;react&quot;;import ThemeContext from &quot;.&#x2F;theme-context&quot;;type Props &#x3D; &#123;&#125;;export class ToggleThemeButtonClass extends React.Component&lt;Props&gt; &#123; static contextType &#x3D; ThemeContext; context!: React.ContextType&lt;typeof ThemeContext&gt;; render() &#123; const &#123; theme, toggleTheme &#125; &#x3D; this.context; return ( &lt;button style&#x3D;&#123;theme&#125; onClick&#x3D;&#123;toggleTheme&#125;&gt; Toggle Theme &lt;&#x2F;button&gt; ); &#125;&#125; Implementation with Hooks ⇧ back to top Hooks https://reactjs.org/docs/hooks-intro.html - useState https://reactjs.org/docs/hooks-reference.html#usestate 123456789101112131415import * as React from &quot;react&quot;;type Props &#x3D; &#123; initialCount: number &#125;;export default function Counter(&#123; initialCount &#125;: Props) &#123; const [count, setCount] &#x3D; React.useState(initialCount); return ( &lt;&gt; Count: &#123;count&#125; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(initialCount)&#125;&gt;Reset&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount((prevCount) &#x3D;&gt; prevCount + 1)&#125;&gt;+&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount((prevCount) &#x3D;&gt; prevCount - 1)&#125;&gt;-&lt;&#x2F;button&gt; &lt;&#x2F;&gt; );&#125; ⇧ back to top - useReducerHook for state management like Redux in a function component. 1234567891011121314151617181920212223242526272829303132333435363738394041import * as React from &quot;react&quot;;interface State &#123; count: number;&#125;type Action &#x3D; &#123; type: &quot;reset&quot; &#125; | &#123; type: &quot;increment&quot; &#125; | &#123; type: &quot;decrement&quot; &#125;;function reducer(state: State, action: Action): State &#123; switch (action.type) &#123; case &quot;increment&quot;: return &#123; count: state.count + 1 &#125;; case &quot;decrement&quot;: return &#123; count: state.count - 1 &#125;; case &quot;reset&quot;: return &#123; count: 0 &#125;; default: throw new Error(); &#125;&#125;interface CounterProps &#123; initialCount: number;&#125;function Counter(&#123; initialCount &#125;: CounterProps) &#123; const [state, dispatch] &#x3D; React.useReducer(reducer, &#123; count: initialCount, &#125;); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &quot;reset&quot; &#125;)&#125;&gt;Reset&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &quot;increment&quot; &#125;)&#125;&gt;+&lt;&#x2F;button&gt; &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &quot;decrement&quot; &#125;)&#125;&gt;-&lt;&#x2F;button&gt; &lt;&#x2F;&gt; );&#125;export default Counter; ⇧ back to top - useContext https://reactjs.org/docs/hooks-reference.html#usecontext 12345678910111213import * as React from &quot;react&quot;;import ThemeContext from &quot;..&#x2F;context&#x2F;theme-context&quot;;type Props &#x3D; &#123;&#125;;export default function ThemeToggleButton(props: Props) &#123; const &#123; theme, toggleTheme &#125; &#x3D; React.useContext(ThemeContext); return ( &lt;button onClick&#x3D;&#123;toggleTheme&#125; style&#x3D;&#123;theme&#125;&gt; Toggle Theme &lt;&#x2F;button&gt; );&#125; ⇧ back to top Redux - Typing PatternsStore ConfigurationCreate Global Store TypesRootState - type representing root state-treeCan be imported in connected components to provide type-safety to Redux connect function RootAction - type representing union type of all action objectsCan be imported in various layers receiving or sending redux actions like: reducers, sagas or redux-observables epics 123456789101112131415import &#123; StateType, ActionType &#125; from &quot;typesafe-actions&quot;;declare module &quot;MyTypes&quot; &#123; export type Store &#x3D; StateType&lt;typeof import(&quot;.&#x2F;index&quot;).default&gt;; export type RootAction &#x3D; ActionType&lt;typeof import(&quot;.&#x2F;root-action&quot;).default&gt;; export type RootState &#x3D; StateType&lt; ReturnType&lt;typeof import(&quot;.&#x2F;root-reducer&quot;).default&gt; &gt;;&#125;declare module &quot;typesafe-actions&quot; &#123; interface Types &#123; RootAction: ActionType&lt;typeof import(&quot;.&#x2F;root-action&quot;).default&gt;; &#125;&#125; ⇧ back to top Create StoreWhen creating a store instance we don’t need to provide any additional types. It will set-up a type-safe Store instance using type inference. The resulting store instance methods like getState or dispatch will be type checked and will expose all type errors 12345678910111213141516171819202122232425262728293031323334353637383940import &#123; RootAction, RootState, Services &#125; from &quot;MyTypes&quot;;import &#123; createStore, applyMiddleware &#125; from &quot;redux&quot;;import &#123; createEpicMiddleware &#125; from &quot;redux-observable&quot;;import &#123; createBrowserHistory &#125; from &quot;history&quot;;import &#123; routerMiddleware as createRouterMiddleware &#125; from &quot;connected-react-router&quot;;import &#123; composeEnhancers &#125; from &quot;.&#x2F;utils&quot;;import rootReducer from &quot;.&#x2F;root-reducer&quot;;import rootEpic from &quot;.&#x2F;root-epic&quot;;import services from &quot;..&#x2F;services&quot;;&#x2F;&#x2F; browser historyexport const history &#x3D; createBrowserHistory();export const epicMiddleware &#x3D; createEpicMiddleware&lt; RootAction, RootAction, RootState, Services&gt;(&#123; dependencies: services,&#125;);const routerMiddleware &#x3D; createRouterMiddleware(history);&#x2F;&#x2F; configure middlewaresconst middlewares &#x3D; [epicMiddleware, routerMiddleware];&#x2F;&#x2F; compose enhancersconst enhancer &#x3D; composeEnhancers(applyMiddleware(...middlewares));&#x2F;&#x2F; rehydrate state on app startconst initialState &#x3D; &#123;&#125;;&#x2F;&#x2F; create storeconst store &#x3D; createStore(rootReducer(history), initialState, enhancer);epicMiddleware.run(rootEpic);&#x2F;&#x2F; export store singleton instanceexport default store; Action Creators 🌟 We’ll be using a battle-tested helper library typesafe-actions that’s designed to make it easy and fun working with Redux in TypeScript. To learn more please check this in-depth tutorial: Typesafe-Actions - Tutorial! A solution below is using a simple factory function to automate the creation of type-safe action creators. The goal is to decrease maintenance effort and reduce code repetition of type annotations for actions and creators. The result is completely typesafe action-creators and their actions. 1234567891011121314151617181920212223242526272829&#x2F;* eslint-disable *&#x2F;import &#123; action &#125; from &quot;typesafe-actions&quot;;import &#123; ADD, INCREMENT &#125; from &quot;.&#x2F;constants&quot;;&#x2F;* SIMPLE API *&#x2F;export const increment &#x3D; () &#x3D;&gt; action(INCREMENT);export const add &#x3D; (amount: number) &#x3D;&gt; action(ADD, amount);&#x2F;* ADVANCED API *&#x2F;&#x2F;&#x2F; More flexible allowing to create complex actions more easily&#x2F;&#x2F; use can use &quot;action-creator&quot; instance in place of &quot;type constant&quot;&#x2F;&#x2F; e.g. case getType(increment): return action.payload;&#x2F;&#x2F; This will allow to completely eliminate need for &quot;constants&quot; in your application, more info here:&#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;piotrwitek&#x2F;typesafe-actions#constantsimport &#123; createAction &#125; from &quot;typesafe-actions&quot;;import &#123; Todo &#125; from &quot;..&#x2F;todos&#x2F;models&quot;;export const emptyAction &#x3D; createAction(INCREMENT)&lt;void&gt;();export const payloadAction &#x3D; createAction(ADD)&lt;number&gt;();export const payloadMetaAction &#x3D; createAction(ADD)&lt;number, string&gt;();export const payloadCreatorAction &#x3D; createAction( &quot;TOGGLE_TODO&quot;, (todo: Todo) &#x3D;&gt; todo.id)&lt;string&gt;(); Click to expand 12345678import store from &quot;..&#x2F;..&#x2F;store&quot;;import &#123; countersActions as counter &#125; from &quot;..&#x2F;counters&quot;;&#x2F;&#x2F; store.dispatch(counter.increment(1)); &#x2F;&#x2F; Error: Expected 0 arguments, but got 1.store.dispatch(counter.increment()); &#x2F;&#x2F; OK&#x2F;&#x2F; store.dispatch(counter.add()); &#x2F;&#x2F; Error: Expected 1 arguments, but got 0.store.dispatch(counter.add(1)); &#x2F;&#x2F; OK ⇧ back to top ReducersState with Type-level ImmutabilityDeclare reducer State type with readonly modifier to get compile time immutability 1234export type State = &#123; readonly counter: number; readonly todos: ReadonlyArray&lt;string&gt;;&#125;; Readonly modifier allow initialization, but will not allow reassignment by highlighting compiler errors 12345export const initialState: State = &#123; counter: 0,&#125;; // OKinitialState.counter = 3; // TS Error: cannot be mutated It’s great for Arrays in JS because it will error when using mutator methods like (push, pop, splice, …), but it’ll still allow immutable methods like (concat, map, slice,…). 12state.todos.push(\"Learn about tagged union types\"); // TS Error: Property 'push' does not exist on type 'ReadonlyArray&lt;string&gt;'const newTodos = state.todos.concat(\"Learn about tagged union types\"); // OK Caveat - Readonly is not recursiveThis means that the readonly modifier doesn’t propagate immutability down the nested structure of objects. You’ll need to mark each property on each level explicitly. TIP: use Readonly or ReadonlyArray Mapped types 123456789101112export type State = Readonly&lt;&#123; counterPairs: ReadonlyArray&lt; Readonly&lt;&#123; immutableCounter1: number; immutableCounter2: number; &#125;&gt; &gt;;&#125;&gt;;state.counterPairs[0] = &#123; immutableCounter1: 1, immutableCounter2: 1 &#125;; // TS Error: cannot be mutatedstate.counterPairs[0].immutableCounter1 = 1; // TS Error: cannot be mutatedstate.counterPairs[0].immutableCounter2 = 1; // TS Error: cannot be mutated Solution - recursive Readonly is called DeepReadonlyTo fix this we can use DeepReadonly type (available from utility-types). 123456789101112import &#123; DeepReadonly &#125; from \"utility-types\";export type State = DeepReadonly&lt;&#123; containerObject: &#123; innerValue: number; numbers: number[]; &#125;;&#125;&gt;;state.containerObject = &#123; innerValue: 1 &#125;; // TS Error: cannot be mutatedstate.containerObject.innerValue = 1; // TS Error: cannot be mutatedstate.containerObject.numbers.push(1); // TS Error: cannot use mutator methods ⇧ back to top Typing reducer to understand following section make sure to learn about Type Inference, Control flow analysis and Tagged union types 123456789101112131415161718192021222324252627282930313233343536373839404142434445import &#123; combineReducers &#125; from &quot;redux&quot;;import &#123; ActionType &#125; from &quot;typesafe-actions&quot;;import &#123; Todo, TodosFilter &#125; from &quot;.&#x2F;models&quot;;import * as actions from &quot;.&#x2F;actions&quot;;import &#123; ADD, CHANGE_FILTER, TOGGLE &#125; from &quot;.&#x2F;constants&quot;;export type TodosAction &#x3D; ActionType&lt;typeof actions&gt;;export type TodosState &#x3D; Readonly&lt;&#123; todos: Todo[]; todosFilter: TodosFilter;&#125;&gt;;const initialState: TodosState &#x3D; &#123; todos: [], todosFilter: TodosFilter.All,&#125;;export default combineReducers&lt;TodosState, TodosAction&gt;(&#123; todos: (state &#x3D; initialState.todos, action) &#x3D;&gt; &#123; switch (action.type) &#123; case ADD: return [...state, action.payload]; case TOGGLE: return state.map((item) &#x3D;&gt; item.id &#x3D;&#x3D;&#x3D; action.payload ? &#123; ...item, completed: !item.completed &#125; : item ); default: return state; &#125; &#125;, todosFilter: (state &#x3D; initialState.todosFilter, action) &#x3D;&gt; &#123; switch (action.type) &#123; case CHANGE_FILTER: return action.payload; default: return state; &#125; &#125;,&#125;); ⇧ back to top Typing reducer with typesafe-actions Notice we are not required to use any generic type parameter in the API. Try to compare it with regular reducer as they are equivalent. 12345678910111213141516171819202122232425262728293031323334import &#123; combineReducers &#125; from &quot;redux&quot;;import &#123; createReducer &#125; from &quot;typesafe-actions&quot;;import &#123; Todo, TodosFilter &#125; from &quot;.&#x2F;models&quot;;import &#123; ADD, CHANGE_FILTER, TOGGLE &#125; from &quot;.&#x2F;constants&quot;;export type TodosState &#x3D; Readonly&lt;&#123; todos: Todo[]; todosFilter: TodosFilter;&#125;&gt;;const initialState: TodosState &#x3D; &#123; todos: [], todosFilter: TodosFilter.All,&#125;;const todos &#x3D; createReducer(initialState.todos) .handleType(ADD, (state, action) &#x3D;&gt; [...state, action.payload]) .handleType(TOGGLE, (state, action) &#x3D;&gt; state.map((item) &#x3D;&gt; item.id &#x3D;&#x3D;&#x3D; action.payload ? &#123; ...item, completed: !item.completed &#125; : item ) );const todosFilter &#x3D; createReducer(initialState.todosFilter).handleType( CHANGE_FILTER, (state, action) &#x3D;&gt; action.payload);export default combineReducers(&#123; todos, todosFilter,&#125;); ⇧ back to top Testing reducer12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; todosReducer as reducer, todosActions as actions, TodosState,&#125; from &quot;.&#x2F;&quot;;&#x2F;** * FIXTURES *&#x2F;const getInitialState &#x3D; (initial?: Partial&lt;TodosState&gt;) &#x3D;&gt; reducer(initial as TodosState, &#123;&#125; as any);&#x2F;** * STORIES *&#x2F;describe(&quot;Todos Stories&quot;, () &#x3D;&gt; &#123; describe(&quot;initial state&quot;, () &#x3D;&gt; &#123; it(&quot;should match a snapshot&quot;, () &#x3D;&gt; &#123; const initialState &#x3D; getInitialState(); expect(initialState).toMatchSnapshot(); &#125;); &#125;); describe(&quot;adding todos&quot;, () &#x3D;&gt; &#123; it(&quot;should add a new todo as the first element&quot;, () &#x3D;&gt; &#123; const initialState &#x3D; getInitialState(); expect(initialState.todos).toHaveLength(0); const state &#x3D; reducer(initialState, actions.add(&quot;new todo&quot;)); expect(state.todos).toHaveLength(1); expect(state.todos[0].title).toEqual(&quot;new todo&quot;); &#125;); &#125;); describe(&quot;toggling completion state&quot;, () &#x3D;&gt; &#123; it(&quot;should mark active todo as complete&quot;, () &#x3D;&gt; &#123; const activeTodo &#x3D; &#123; id: &quot;1&quot;, completed: false, title: &quot;active todo&quot; &#125;; const initialState &#x3D; getInitialState(&#123; todos: [activeTodo] &#125;); expect(initialState.todos[0].completed).toBeFalsy(); const state1 &#x3D; reducer(initialState, actions.toggle(activeTodo.id)); expect(state1.todos[0].completed).toBeTruthy(); &#125;); &#125;);&#125;); ⇧ back to top Async Flow with redux-observableTyping epics12345678910111213141516171819202122import &#123; RootAction, RootState, Services &#125; from &quot;MyTypes&quot;;import &#123; Epic &#125; from &quot;redux-observable&quot;;import &#123; tap, ignoreElements, filter &#125; from &quot;rxjs&#x2F;operators&quot;;import &#123; isOfType &#125; from &quot;typesafe-actions&quot;;import &#123; todosConstants &#125; from &quot;..&#x2F;todos&quot;;&#x2F;&#x2F; contrived example!!!export const logAddAction: Epic&lt;RootAction, RootAction, RootState, Services&gt; &#x3D; ( action$, state$, &#123; logger &#125;) &#x3D;&gt; action$.pipe( filter(isOfType(todosConstants.ADD)), &#x2F;&#x2F; action is narrowed to: &#123; type: &quot;ADD_TODO&quot;; payload: string; &#125; tap((action) &#x3D;&gt; &#123; logger.log( &#96;action type must be equal: $&#123;todosConstants.ADD&#125; &#x3D;&#x3D;&#x3D; $&#123;action.type&#125;&#96; ); &#125;), ignoreElements() ); ⇧ back to top Testing epics12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import &#123; StateObservable, ActionsObservable &#125; from &quot;redux-observable&quot;;import &#123; RootState, Services, RootAction &#125; from &quot;MyTypes&quot;;import &#123; Subject &#125; from &quot;rxjs&quot;;import &#123; add &#125; from &quot;.&#x2F;actions&quot;;import &#123; logAddAction &#125; from &quot;.&#x2F;epics&quot;;&#x2F;&#x2F; Simple typesafe mock of all the services, you dont&#39;t need to mock anything else&#x2F;&#x2F; It is decoupled and reusable for all your tests, just put it in a separate fileconst services &#x3D; &#123; logger: &#123; log: jest.fn&lt;Services[&quot;logger&quot;][&quot;log&quot;]&gt;(), &#125;, localStorage: &#123; loadState: jest.fn&lt;Services[&quot;localStorage&quot;][&quot;loadState&quot;]&gt;(), saveState: jest.fn&lt;Services[&quot;localStorage&quot;][&quot;saveState&quot;]&gt;(), &#125;,&#125;;describe(&quot;Todos Epics&quot;, () &#x3D;&gt; &#123; let state$: StateObservable&lt;RootState&gt;; beforeEach(() &#x3D;&gt; &#123; state$ &#x3D; new StateObservable&lt;RootState&gt;( new Subject&lt;RootState&gt;(), undefined as any ); &#125;); describe(&quot;logging todos actions&quot;, () &#x3D;&gt; &#123; beforeEach(() &#x3D;&gt; &#123; services.logger.log.mockClear(); &#125;); it(&quot;should call the logger service when adding a new todo&quot;, (done) &#x3D;&gt; &#123; const addTodoAction &#x3D; add(&quot;new todo&quot;); const action$ &#x3D; ActionsObservable.of(addTodoAction); logAddAction(action$, state$, services) .toPromise() .then((outputAction: RootAction) &#x3D;&gt; &#123; expect(services.logger.log).toHaveBeenCalledTimes(1); expect(services.logger.log).toHaveBeenCalledWith( &quot;action type must be equal: todos&#x2F;ADD &#x3D;&#x3D;&#x3D; todos&#x2F;ADD&quot; ); &#x2F;&#x2F; expect output undefined because we&#39;re using &quot;ignoreElements&quot; in epic expect(outputAction).toEqual(undefined); done(); &#125;); &#125;); &#125;);&#125;); ⇧ back to top Selectors with reselect1234567891011121314151617181920212223import &#123; createSelector &#125; from &quot;reselect&quot;;import &#123; TodosState &#125; from &quot;.&#x2F;reducer&quot;;export const getTodos &#x3D; (state: TodosState) &#x3D;&gt; state.todos;export const getTodosFilter &#x3D; (state: TodosState) &#x3D;&gt; state.todosFilter;export const getFilteredTodos &#x3D; createSelector( getTodos, getTodosFilter, (todos, todosFilter) &#x3D;&gt; &#123; switch (todosFilter) &#123; case &quot;completed&quot;: return todos.filter((t) &#x3D;&gt; t.completed); case &quot;active&quot;: return todos.filter((t) &#x3D;&gt; !t.completed); default: return todos; &#125; &#125;); ⇧ back to top Connect with react-reduxTyping connected componentNOTE: Below you’ll find only a short explanation of concepts behind typing connect. For more real-world examples please check Redux Connected Components section. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import MyTypes from &quot;MyTypes&quot;;import &#123; bindActionCreators, Dispatch, ActionCreatorsMapObject &#125; from &quot;redux&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; countersActions &#125; from &quot;..&#x2F;features&#x2F;counters&quot;;import &#123; FCCounter &#125; from &quot;..&#x2F;components&quot;;&#x2F;&#x2F; Type annotation for &quot;state&quot; argument is mandatory to check&#x2F;&#x2F; the correct shape of state object and injected props you can also&#x2F;&#x2F; extend connected component Props interface by annotating &#96;ownProps&#96; argumentconst mapStateToProps &#x3D; ( state: MyTypes.RootState, ownProps: FCCounterProps) &#x3D;&gt; (&#123; count: state.counters.reduxCounter,&#125;);&#x2F;&#x2F; &quot;dispatch&quot; argument needs an annotation to check the correct shape&#x2F;&#x2F; of an action object when using dispatch functionconst mapDispatchToProps &#x3D; (dispatch: Dispatch&lt;MyTypes.RootAction&gt;) &#x3D;&gt; bindActionCreators( &#123; onIncrement: countersActions.increment, &#125;, dispatch );&#x2F;&#x2F; shorter alternative is to use an object instead of mapDispatchToProps functionconst dispatchToProps &#x3D; &#123; onIncrement: countersActions.increment,&#125;;&#x2F;&#x2F; Notice we don&#39;t need to pass any generic type parameters to neither&#x2F;&#x2F; the connect function below nor map functions declared above&#x2F;&#x2F; because type inference will infer types from arguments annotations automatically&#x2F;&#x2F; This is much cleaner and idiomatic approachexport const FCCounterConnected &#x3D; connect( mapStateToProps, mapDispatchToProps)(FCCounter);&#x2F;&#x2F; You can add extra layer of validation of your action creators&#x2F;&#x2F; by using bindActionCreators generic type parameter and RootAction typeconst mapDispatchToProps &#x3D; (dispatch: Dispatch&lt;MyTypes.RootAction&gt;) &#x3D;&gt; bindActionCreators&lt;ActionCreatorsMapObject&lt;Types.RootAction&gt;&gt;( &#123; invalidActionCreator: () &#x3D;&gt; 1, &#x2F;&#x2F; Error: Type &#39;number&#39; is not assignable to type &#39;&#123; type: &quot;todos&#x2F;ADD&quot;; payload: Todo; &#125; | &#123; ... &#125; &#125;, dispatch ); Typing connected component with redux-thunk integrationNOTE: When using thunk action creators you need to use bindActionCreators. Only this way you can get corrected dispatch props type signature like below. WARNING: As of now (Apr 2019) bindActionCreators signature of the latest redux-thunk release will not work as below, you need to use updated type definitions that you can find here /playground/typings/redux-thunk/index.d.ts and then add paths overload in your tsconfig like this: &quot;paths&quot;:{&quot;redux-thunk&quot;:[&quot;typings/redux-thunk&quot;]}. 1234567891011121314151617const thunkAsyncAction &#x3D; () &#x3D;&gt; async (dispatch: Dispatch): Promise&lt;void&gt; &#x3D;&gt; &#123; &#x2F;&#x2F; dispatch actions, return Promise, etc.&#125;;const mapDispatchToProps &#x3D; (dispatch: Dispatch&lt;Types.RootAction&gt;) &#x3D;&gt; bindActionCreators( &#123; thunkAsyncAction, &#125;, dispatch );type DispatchProps &#x3D; ReturnType&lt;typeof mapDispatchToProps&gt;;&#x2F;&#x2F; &#123; thunkAsyncAction: () &#x3D;&gt; Promise&lt;void&gt;; &#125;&#x2F;* Without &quot;bindActionCreators&quot; fix signature will be the same as the original &quot;unbound&quot; thunk function: *&#x2F;&#x2F;&#x2F; &#123; thunkAsyncAction: () &#x3D;&gt; (dispatch: Dispatch&lt;AnyAction&gt;) &#x3D;&gt; Promise&lt;void&gt;; &#125; ⇧ back to top Configuration &amp; Dev ToolsCommon Npm Scripts Common TS-related npm scripts shared across projects 123456789&quot;prettier&quot;: &quot;prettier --list-different &#39;src&#x2F;**&#x2F;*.ts&#39; || (echo &#39;\\nPlease fix code formatting by running:\\nnpm run prettier:fix\\n&#39;; exit 1)&quot;,&quot;prettier:fix&quot;: &quot;prettier --write &#39;src&#x2F;**&#x2F;*.ts&#39;&quot;,&quot;lint&quot;: &quot;tslint -p .&#x2F;&quot;,&quot;tsc&quot;: &quot;tsc -p .&#x2F; --noEmit&quot;,&quot;tsc:watch&quot;: &quot;tsc -p .&#x2F; --noEmit -w&quot;,&quot;test&quot;: &quot;jest --config jest.config.json&quot;,&quot;test:watch&quot;: &quot;jest --config jest.config.json --watch&quot;,&quot;test:update&quot;: &quot;jest --config jest.config.json -u&quot;&quot;ci-check&quot;: &quot;npm run prettier &amp;&amp; npm run lint &amp;&amp; npm run tsc &amp;&amp; npm run test&quot;, ⇧ back to top tsconfig.jsonWe have our own recommended tsconfig.json that you can easily add to your project thanks to react-redux-typescript-scripts package. Click to expand 1234567891011&#123; &quot;include&quot;: [ &quot;src&quot;, &quot;typings&quot; ], &quot;exclude&quot;: [ &quot;src&#x2F;**&#x2F;*.spec.*&quot; ], &quot;extends&quot;: &quot;.&#x2F;node_modules&#x2F;react-redux-typescript-scripts&#x2F;tsconfig.json&quot;, &quot;compilerOptions&quot;: &#123;&#125;&#125; ⇧ back to top TSLibhttps://www.npmjs.com/package/tslib This library will cut down on your bundle size, thanks to using external runtime helpers instead of adding them per each file. Installationnpm i tslib Then add this to your tsconfig.json: 123\"compilerOptions\": &#123; \"importHelpers\": true&#125; ⇧ back to top TSLinthttps://palantir.github.io/tslint/ Installationnpm i -D tslint For React project you should add additional react specific rules: npm i -D tslint-react https://github.com/palantir/tslint-react We have our own recommended config that you can easily add to your project thanks to react-redux-typescript-scripts package. tslint.jsonClick to expand 123456789&#123; &quot;extends&quot;: [ &quot;.&#x2F;node_modules&#x2F;react-redux-typescript-scripts&#x2F;tslint.json&quot;, &quot;.&#x2F;node_modules&#x2F;react-redux-typescript-scripts&#x2F;tslint-react.json&quot; ], &quot;rules&quot;: &#123; &#x2F;&#x2F; you can further customize options here &#125;&#125; ⇧ back to top ESLinthttps://eslint.org/https://typescript-eslint.io Installationnpm i -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin We have our own recommended config that will automatically add a parser &amp; plugin for TypeScript thanks to react-redux-typescript-scripts package. .eslintrcClick to expand 123456789&#123; &quot;extends&quot;: [ &quot;react-app&quot;, &quot;.&#x2F;node_modules&#x2F;react-redux-typescript-scripts&#x2F;eslint.js&quot; ], &quot;rules&quot;: &#123; &#x2F;&#x2F; you can further customize options here &#125;&#125; ⇧ back to top Jesthttps://jestjs.io/ Installationnpm i -D jest ts-jest @types/jest jest.config.jsonClick to expand 12345678910111213141516171819&#123; &quot;verbose&quot;: true, &quot;transform&quot;: &#123; &quot;.(ts|tsx)&quot;: &quot;ts-jest&quot; &#125;, &quot;testRegex&quot;: &quot;(&#x2F;spec&#x2F;.*|\\\\.(test|spec))\\\\.(ts|tsx|js)$&quot;, &quot;moduleFileExtensions&quot;: [&quot;ts&quot;, &quot;tsx&quot;, &quot;js&quot;], &quot;moduleNameMapper&quot;: &#123; &quot;^Components&#x2F;(.*)&quot;: &quot;.&#x2F;src&#x2F;components&#x2F;$1&quot; &#125;, &quot;globals&quot;: &#123; &quot;window&quot;: &#123;&#125;, &quot;ts-jest&quot;: &#123; &quot;tsConfig&quot;: &quot;.&#x2F;tsconfig.json&quot; &#125; &#125;, &quot;setupFiles&quot;: [&quot;.&#x2F;jest.stubs.js&quot;], &quot;testURL&quot;: &quot;http:&#x2F;&#x2F;localhost&#x2F;&quot;&#125; jest.stubs.jsClick to expand 123456789101112131415161718192021&#x2F;&#x2F; Global&#x2F;Window object Stubs for Jestwindow.matchMedia &#x3D; window.matchMedia || function() &#123; return &#123; matches: false, addListener: function() &#123;&#125;, removeListener: function() &#123;&#125;, &#125;; &#125;;window.requestAnimationFrame &#x3D; function(callback) &#123; setTimeout(callback);&#125;;window.localStorage &#x3D; &#123; getItem: function() &#123;&#125;, setItem: function() &#123;&#125;,&#125;;Object.values &#x3D; () &#x3D;&gt; []; ⇧ back to top Style Guides“react-styleguidist”⟩⟩⟩ styleguide.config.js ⟩⟩⟩ demo ⇧ back to top RecipesGeneral Tips- should I still use React.PropTypes in TS?No. With TypeScript, using PropTypes is an unnecessary overhead. When declaring Props and State interfaces, you will get complete intellisense and design-time safety with static type checking. This way you’ll be safe from runtime errors and you will save a lot of time on debugging. Additional benefit is an elegant and standardized method of documenting your component public API in the source code. ⇧ back to top - when to use interface declarations and when type aliases?From practical side, using interface declaration will create an identity (interface name) in compiler errors, on the contrary type aliases doesn’t create an identity and will be unwinded to show all the properties and nested types it consists of.Although I prefer to use type most of the time there are some places this can become too noisy when reading compiler errors and that’s why I like to leverage this distinction to hide some of not so important type details in errors using interfaces identity.Related ts-lint rule: https://palantir.github.io/tslint/rules/interface-over-type-literal/ ⇧ back to top - what’s better default or named exports?A common flexible solution is to use module folder pattern, because you can leverage both named and default import when you see fit.With this solution you’ll achieve better encapsulation and be able to safely refactor internal naming and folders structure without breaking your consumer code: 1234567891011121314151617181920// 1. create your component files (`select.tsx`) using default export in some folder:// components/select.tsxconst Select: React.FC&lt;Props&gt; = (props) =&gt; &#123;...export default Select;// 2. in this folder create an `index.ts` file that will re-export components with named exports:// components/index.tsexport &#123; default as Select &#125; from './select';...// 3. now you can import your components in both ways, with named export (better encapsulation) or using default export (internal access):// containers/container.tsximport &#123; Select &#125; from '@src/components';orimport Select from '@src/components/select';... ⇧ back to top - how to best initialize class instance or static properties?Prefered modern syntax is to use class Property Initializers 12345678910111213class ClassCounterWithInitialCount extends React.Component&lt;Props, State&gt; &#123; &#x2F;&#x2F; default props using Property Initializers static defaultProps: DefaultProps &#x3D; &#123; className: &#39;default-class&#39;, initialCount: 0, &#125;; &#x2F;&#x2F; initial state using Property Initializers state: State &#x3D; &#123; count: this.props.initialCount, &#125;; ...&#125; ⇧ back to top - how to best declare component handler functions?Prefered modern syntax is to use Class Fields with arrow functions 1234567class ClassCounter extends React.Component&lt;Props, State&gt; &#123;&#x2F;&#x2F; handlers using Class Fields with arrow functions handleIncrement &#x3D; () &#x3D;&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125;; ...&#125; ⇧ back to top Ambient Modules TipsImports in ambient modulesFor type augmentation imports should stay outside of module declaration. 12345678import &#123; Operator &#125; from \"rxjs/Operator\";import &#123; Observable &#125; from \"rxjs/Observable\";declare module \"rxjs/Subject\" &#123; interface Subject&lt;T&gt; &#123; lift&lt;R&gt;(operator: Operator&lt;T, R&gt;): Observable&lt;R&gt;; &#125;&#125; When creating 3rd party type-definitions all the imports should be kept inside the module declaration, otherwise it will be treated as augmentation and show error 1234declare module \"react-custom-scrollbars\" &#123; import * as React from \"react\"; export interface positionValues &#123; ... ⇧ back to top Type-Definitions TipsMissing type-definitions errorif you cannot find types for a third-party module you can provide your own types or disable type-checking for this module using Shorthand Ambient Modules 123&#x2F;&#x2F; typings&#x2F;modules.d.tsdeclare module &quot;MyTypes&quot;;declare module &quot;react-test-renderer&quot;; Using custom d.ts files for npm modulesIf you want to use an alternative (customized) type-definitions for some npm module (that usually comes with it’s own type-definitions), you can do it by adding an override in paths compiler option. 12345678910&#123; \"compilerOptions\": &#123; \"baseUrl\": \".\", \"paths\": &#123; \"redux\": [\"typings/redux\"], // use an alternative type-definitions instead of the included one ... &#125;, ..., &#125;&#125; ⇧ back to top Type Augmentation TipsStrategies to fix issues coming from external type-definitions files (*.d.ts) Augmenting library internal declarations - using relative import123456// added missing autoFocus Prop on Input component in \"antd@2.10.0\" npm packagedeclare module \"../node_modules/antd/lib/input/Input\" &#123; export interface InputProps &#123; autoFocus?: boolean; &#125;&#125; Augmenting library public declarations - using node_modules import123456789// fixed broken public type-definitions in \"rxjs@5.4.1\" npm packageimport &#123; Operator &#125; from \"rxjs/Operator\";import &#123; Observable &#125; from \"rxjs/Observable\";declare module \"rxjs/Subject\" &#123; interface Subject&lt;T&gt; &#123; lift&lt;R&gt;(operator: Operator&lt;T, R&gt;): Observable&lt;R&gt;; &#125;&#125; More advanced scenarios for working with vendor type-definitions can be found here Official TypeScript Docs ⇧ back to top Tutorials &amp; Articles Curated list of relevant in-depth tutorials Higher-Order Components: https://medium.com/@jrwebdev/react-higher-order-component-patterns-in-typescript-42278f7590fb ⇧ back to top ContributorsThanks goes to these wonderful people (emoji key): Piotrek Witek💻 📖 🤔 👀 💬 Kazz Yokomizo💵 🔍 Jake Boone📖 Amit Dahan📖 gulderov📖 Erik Pearson📖 Bryan Mason📖 Jakub Chodorowicz💻 Oleg Maslov🐛 Aaron Westbrook🐛 Peter Blazejewicz📖 Solomon White📖 Levi Rocha📖 Sudachi-kun💵 Sosuke Suzuki💻 Tom Rathbone📖 Arshad Kazmi📖 JeongUkJae📖 This project follows the all-contributors specification. Contributions of any kind welcome! MIT License Copyright (c) 2017 Piotr Witek &#112;&#105;&#x6f;&#116;&#x72;&#x65;&#107;&#46;&#119;&#105;&#116;&#101;&#x6b;&#64;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#99;&#111;&#x6d; (http://piotrwitek.github.io)","categories":[{"name":"文档","slug":"文档","permalink":"https://blog.xiaoz.site/categories/%E6%96%87%E6%A1%A3/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://blog.xiaoz.site/tags/typescript/"},{"name":"react","slug":"react","permalink":"https://blog.xiaoz.site/tags/react/"}]},{"title":"typescript学习(4) 函数","slug":"learn-ts4","date":"2019-05-12T13:30:33.000Z","updated":"2019-09-06T06:15:25.722Z","comments":true,"path":"2019/05/12/learn-ts4/","link":"","permalink":"https://blog.xiaoz.site/2019/05/12/learn-ts4/","excerpt":"函数类型123function add(x: number, y: number): number &#123; return x + y&#125; 完整函数类型1234let myAdd: (baseValue: number, increment: number) =&gt; number =function(x: number, y: number): number &#123; return x + y&#125; ts有类型推断，不需要写的那么完整，上面的例子可以只写左边或右边","text":"函数类型123function add(x: number, y: number): number &#123; return x + y&#125; 完整函数类型1234let myAdd: (baseValue: number, increment: number) =&gt; number =function(x: number, y: number): number &#123; return x + y&#125; ts有类型推断，不需要写的那么完整，上面的例子可以只写左边或右边 可选参数和默认参数没传参的时候，它的值就是 undefined，可选参数必须跟在必须参数后面 1let myAdd: (baseValue: number, increment?: number) =&gt; number 默认初始化值的参数：当用户没有传递这个参数或传递的值是 undefined 时，为参数提供一个默认值 123function buildName(firstName: string, lastName = 'Smith'): string &#123; return firstName + ' ' + lastName&#125; 剩余参数想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在 JavaScript 里，你可以使用 arguments 来访问所有传入的参数。 在 TypeScript 里，你可以把所有参数收集到一个变量里： 12345function buildName(firstName: string, ...restOfName: string[]): string &#123; return firstName + ' ' + restOfName.join(' ')&#125;let employeeName = buildName('Joseph', 'Samuel', 'Lucas', 'MacKinzie') thisTypeScript 能通知你错误地使用了 this 的地方 this 和箭头函数箭头函数能保存函数创建时的 this 值，而不是调用时的值 this 参数可以提供一个显式的 this 参数。 this 参数是个假的参数，它出现在参数列表的最前面： 123function f(this: void) &#123; // 确保“this”在此独立函数中不可用&#125; 一个定义 this 参数的例子 123456789101112131415161718192021222324252627282930interface Card &#123; suit: string card: number&#125;interface Deck &#123; suits: string[] cards: number[] createCardPicker (this: Deck): () =&gt; Card&#125;let deck: Deck = &#123; suits: ['hearts', 'spades', 'clubs', 'diamonds'], cards: Array(52), // NOTE: 函数现在显式指定其被调用方必须是 deck 类型 createCardPicker: function (this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52) let pickedSuit = Math.floor(pickedCard / 13) // console.log(this.a) // Property 'a' does not exist on type 'Deck' return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125; &#125; &#125;&#125;let cardPicker = deck.createCardPicker()let pickedCard = cardPicker()console.log('card: ' + pickedCard.card + ' of ' + pickedCard.suit) 函数重载JavaScript 本身是个动态语言。JavaScript 里函数根据传入不同的参数而返回不同类型的数据的场景是很常见的。方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 1234567891011121314151617181920212223let suits = ['hearts', 'spades', 'clubs', 'diamonds']function pickCard(x: &#123;suit: string; card: number &#125;[]): numberfunction pickCard(x: number): &#123;suit: string; card: number &#125;function pickCard(x): any &#123; if (Array.isArray(x)) &#123; let pickedCard = Math.floor(Math.random() * x.length) return pickedCard &#125; else if (typeof x === 'number') &#123; let pickedSuit = Math.floor(x / 13) return &#123; suit: suits[pickedSuit], card: x % 13 &#125; &#125;&#125;let myDeck = [ &#123; suit: 'diamonds', card: 2 &#125;, &#123; suit: 'spades', card: 10 &#125;, &#123; suit: 'hearts', card: 4 &#125;]let pickedCard1 = myDeck[pickCard(myDeck)];let pickedCard2 = pickCard(15)let pickedCard3 = pickCard('aaa') // error 类型“\"aaa\"”的参数不能赋给类型“number”的参数 重载的 pickCard 函数在调用的时候会进行正确的类型检查","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"typescript","slug":"学习笔记/typescript","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://blog.xiaoz.site/tags/typescript/"}]},{"title":"typescript学习(3) 类","slug":"learn-ts3","date":"2019-05-11T15:44:09.000Z","updated":"2019-09-06T06:15:25.722Z","comments":true,"path":"2019/05/11/learn-ts3/","link":"","permalink":"https://blog.xiaoz.site/2019/05/11/learn-ts3/","excerpt":"简单介绍123456789class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; move(distance: number = 0): void &#123; console.log(`$&#123;this.name&#125; moved $&#123;distance&#125;`); &#125;&#125; 继承面向对象模式，基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类","text":"简单介绍123456789class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; move(distance: number = 0): void &#123; console.log(`$&#123;this.name&#125; moved $&#123;distance&#125;`); &#125;&#125; 继承面向对象模式，基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类 1234567891011121314151617181920212223242526272829303132333435class Animal &#123; name: string constructor(name: string) &#123; this.name = name &#125; move(distance: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distance&#125;m.`) &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name) &#125; move(distance: number = 5) &#123; console.log('Slithering...') super.move(distance) &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name) &#125; move(distance: number = 45) &#123; console.log('Galloping...') super.move(distance) &#125;&#125;let sam = new Snake('Sammy')let tom: Animal = new Horse('Tommy')sam.move()tom.move(34) 派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this 的属性之前，我们 一定要调用 super()。 这个是 TypeScript 强制执行的一条重要规则。 这个例子演示了如何在子类里可以重写父类的方法。Snake类和 Horse 类都创建了 move 方法，它们重写了从 Animal 继承来的 move 方法，使得 move 方法根据不同的类而具有不同的功能。注意，即使 tom 被声明为 Animal 类型，但因为它的值是 Horse，调用 tom.move(34) 时，它会调用 Horse 里重写的方法。子类方法里使用super调用父类方法 公共，私有与受保护的修饰符publicTypeScript 里，成员都默认为 public private当成员被标记成 private 时，它就不能在声明它的类的外部访问 12345678class Animal &#123; private name: string constructor(name: string) &#123; this.name = name &#125;&#125;new Animal('Cat').name // 错误: 'name' 是私有的. 如果其中一个类型里包含一个 private 成员，那么只有当另外一个类型中也存在这样一个 private 成员，并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected 成员也使用这个规则 protectedprotected 修饰符与 private 修饰符的行为很相似，但有一点不同， protected 成员在派生类中仍然可以访问 1234567891011121314151617181920212223class Person &#123; protected name: string constructor(name: string) &#123; this.name = name &#125;&#125;class Employee extends Person &#123; private department: string constructor(name: string, department: string) &#123; super(name) this.department = department &#125; getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.` &#125;&#125;let howard = new Employee('Howard', 'Sales')console.log(howard.getElevatorPitch())console.log(howard.name) // error 注意，我们不能在 Person 类外使用 name，但是我们仍然可以通过 Employee 类的实例方法访问，因为 Employee 是由 Person 派生而来的。 构造函数也可以被标记成 protected, 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如： 1234567891011121314151617181920212223class Person &#123; protected name: string protected constructor(name: string) &#123; this.name = name &#125;&#125;// Employee 能够继承 Personclass Employee extends Person &#123; private department: string constructor(name: string, department: string) &#123; super(name) this.department = department &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.` &#125;&#125;let howard = new Employee('Howard', 'Sales')let john = new Person('John') // 错误: 'Person' 的构造函数是被保护的. readonly修饰符使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化 123456789class Person &#123; readonly name: string constructor(name: string) &#123; this.name = name &#125;&#125;let john = new Person('John')john.name = 'peter' // error: Cannot assign to 'name' because it is a read-only property 参数属性在上面的例子中，我们必须在 Person 类里定义一个只读成员 name 和一个参数为 name 的构造函数，并且立刻将 name 的值赋给 this.name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Person 类的修改版，使用了参数属性 1234class Person &#123; constructor(readonly name: string) &#123; &#125;&#125; 就是把声明和赋值合并至一处，public,private,protected 也是一样的，但是不建议使用，不清晰 存取器通过 getters/setters 来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问 123456789101112class Human &#123; private _name!: string; // 不加感叹号会报错：属性“_name”没有初始化表达式，且未在构造函数中明确赋值 get name(): string &#123; return this._name; &#125; set name(newName: string) &#123; this._name = `newName:$&#123;newName&#125;`; &#125;&#125;let mike = new Human();mike.name = 'mike'; 静态属性静态属性存在于类本身上面而不是类的实例上 123456789class Human &#123; static age: number = 15; show() &#123; console.log(Human.age); &#125;&#125;const mike = new Human();mike.show(); 抽象类抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法 12345678910111213141516abstract class Animal1 &#123; abstract makeSound(): void; move(): void &#123; console.log('moving'); &#125;&#125;class Bird extends Animal1 &#123; makeSound() &#123; console.log('jiujiujiu'); &#125;&#125;const bird: Bird = new Bird();bird.makeSound();bird.move(); 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。两者都是定义方法签名但不包含方法体。然而，抽象方法必须包含 abstract 关键字并且可以包含访问修饰符，除 private，因为子类需要实现抽象方法 高级技巧构造函数当你在 TypeScript 里声明了一个类的时候，实际上同时声明了很多东西。首先就是类的 实例 的类型。 1234567891011121314class Greeter &#123; static standardGreeting = 'Hello, there' greeting: string constructor(message: string) &#123; this.greeting = message &#125; greet() &#123; return 'Hello, ' + this.greeting &#125;&#125;let greeter: Greetergreeter = new Greeter('world')console.log(greeter.greet()) 这里，我们写了 let greeter: Greeter，意思是 Greeter 类的实例的类型是 Greeter。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。 我们也创建了一个叫做 构造函数 的值 。 这个函数会在我们使用 new 创建类实例的时候被调用。 下面我们来看看，上面的代码被编译成JavaScript后是什么样子的： 12345678910111213var Greeter = /** @class */ (function () &#123; function Greeter(message) &#123; this.greeting = message; &#125; Greeter.prototype.greet = function () &#123; return 'Hello, ' + this.greeting; &#125;; Greeter.standardGreeting = 'Hello, there'; return Greeter;&#125;());var greeter;greeter = new Greeter('world');console.log(greeter.greet()); 上面的代码里，var Greeter 将被构造函数赋值。 当我们调用 new 并执行了这个函数后，便会得到一个类的实例。这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有 实例部分 与 静态部分 这两个部分。 让我们稍微改写一下这个例子，看看它们之间的区别： 123456789101112131415161718192021222324252627class Greeter &#123; static standardGreeting = 'Hello, there' greeting: string constructor(message?: string) &#123; this.greeting = message &#125; greet() &#123; if (this.greeting) &#123; return 'Hello, ' + this.greeting &#125; else &#123; return Greeter.standardGreeting &#125; &#125;&#125;let greeter: Greetergreeter = new Greeter()console.log(greeter.greet())let greeterMaker: typeof Greeter = GreetergreeterMaker.standardGreeting = 'Hey there'let greeter2: Greeter = new greeterMaker()console.log(greeter2.greet()) 这个例子里， greeter1 与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。 再之后，我们直接使用类。 我们创建了一个叫做 greeterMaker 的变量。这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 typeof Greeter，意思是取 Greeter 类的类型，而不是实例的类型。或者更确切的说，”告诉我 Greeter 标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 greeterMaker 上使用 new，创建 Greeter 的实例。 把类当做接口使用如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。 12345678910class Point &#123; x: number y: number&#125;interface Point3d extends Point &#123; z: number&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"typescript","slug":"学习笔记/typescript","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://blog.xiaoz.site/tags/typescript/"}]},{"title":"typescript学习(2) 接口","slug":"learn-ts2","date":"2019-05-09T13:45:30.000Z","updated":"2019-09-06T06:15:25.721Z","comments":true,"path":"2019/05/09/learn-ts2/","link":"","permalink":"https://blog.xiaoz.site/2019/05/09/learn-ts2/","excerpt":"简单介绍TypeScript 的核心原则之一是对值所具有的结构进行类型检查，接口就是对解构的一种描述 1234interface Square &#123; color: string, area?: number // 可选&#125; 只读属性在属性名前用 readonly 来指定只读属性 123456interface Point &#123; readonly x: number readonly y: number&#125;let p1: Point = &#123; x: 10, y: 20 &#125;p1.x = 5 // error!","text":"简单介绍TypeScript 的核心原则之一是对值所具有的结构进行类型检查，接口就是对解构的一种描述 1234interface Square &#123; color: string, area?: number // 可选&#125; 只读属性在属性名前用 readonly 来指定只读属性 123456interface Point &#123; readonly x: number readonly y: number&#125;let p1: Point = &#123; x: 10, y: 20 &#125;p1.x = 5 // error! TypeScript 具有 ReadonlyArray 类型，它与 Array 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改 1234let arr: ReadonlyArray&lt;number&gt; = [1, 2, 3, 4]arr[0] = 66 // error!let arr1: number[] = [1, 2, 3]arr1 = arr // error! 可以看到就算把整个 ReadonlyArray 赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写 1arr1 = arr as number[] 额外的属性检查12345interface SquareConfig &#123; color?: string width?: number [propName: string]: any&#125; 函数接口123interface Func &#123; (param: string): boolean&#125; 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配 12345let func: Funcfunc = function(src: string): boolean &#123; let result = src.search('123'); return result &gt; -1&#125; 可索引的类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 a[10] 或 ageMap[&#39;daniel&#39;]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子： 12345678interface StringArray &#123; [index: number]: string&#125;let myArray: StringArraymyArray = ['Bob', 'Fred']let myStr: string = myArray[0] 上面例子里，我们定义了 StringArray 接口，它具有索引签名。 这个索引签名表示了当用 number 去索引 StringArray 时会得到 string 类型的返回值。 TypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number 来索引时，JavaScript 会将它转换成string 然后再去索引对象。 也就是说用 100（一个 number）去索引等同于使用&#39;100&#39;（一个 string ）去索引，因此两者需要保持一致。 123456789101112class Animal &#123; name: string&#125;class Dog extends Animal &#123; breed: string&#125;// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!interface NotOkay &#123; [x: number]: Animal [x: string]: Dog&#125; 字符串索引签名能够很好的描述 dictionary 模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property 和 obj[&#39;property&#39;] 两种形式都可以。 下面的例子里， name 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示： 12345interface NumberDictionary &#123; [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，`name`的类型与索引类型返回值的类型不匹配&#125; 最后，你可以将索引签名设置为只读，这样就防止了给索引赋值： 12345interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray = ['Alice', 'Bob'];myArray[2] = 'Mallory'; // error! 类实例接口implements 关键字的含义是“实现” 123456789101112interface ClockInterface &#123; currentTime: Date setTime(d: Date):void&#125;class Clock implements ClockInterface &#123; currentTime: Date setTime(d: Date) &#123; this.currentTime = d &#125; constructor(h: number, m: number) &#123; &#125;&#125; 类类型接口123interface ClockConstructor &#123; new (hour: number, minute: number)&#125; 继承接口12345678910interface Shape &#123; color: string&#125;interface Square extends Shape &#123; sideLength: number&#125;let square: Square = &#123; color: 'red', sideLength: 10&#125;; 一个接口可以继承多个接口，创建出多个接口的合成接口 12345678910111213141516interface Shape &#123; color: string&#125;interface PenStroke &#123; penWidth: number&#125;interface Square extends Shape, PenStroke &#123; sideLength: number&#125;let square: Square = &#123; color: 'red', penWidth:20, sideLength: 10&#125;; 接口继承类当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现，使用场景不多 1234567891011121314151617181920class Control &#123; private state: any&#125;interface SelectableControl extends Control &#123; select(): void&#125;class Button extends Control implements SelectableControl &#123; select() &#123; &#125;&#125;class TextBox extends Control &#123; select() &#123; &#125;&#125;// Error：“ImageC”类型缺少“state”属性。class ImageC implements SelectableControl &#123; select() &#123; &#125;&#125; 在上面的例子里，SelectableControl 包含了 Control 的所有成员，包括私有成员 state。 因为 state 是私有成员，所以只能够是 Control 的子类们才能实现 SelectableControl 接口。 因为只有 Control 的子类才能够拥有一个声明于Control 的私有成员 state，这对私有成员的兼容性是必需的。 在 Control 类内部，是允许通过 SelectableControl 的实例来访问私有成员 state 的。 实际上，SelectableControl 接口和拥有 select 方法的 Control 类是一样的。Button和 TextBox 类是 SelectableControl 的子类（因为它们都继承自Control 并有 select 方法），但 ImageC 类并不是这样的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"typescript","slug":"学习笔记/typescript","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://blog.xiaoz.site/tags/typescript/"}]},{"title":"typescript学习(1) 基础类型","slug":"learn-ts1","date":"2019-05-09T13:24:30.000Z","updated":"2019-09-06T06:15:25.721Z","comments":true,"path":"2019/05/09/learn-ts1/","link":"","permalink":"https://blog.xiaoz.site/2019/05/09/learn-ts1/","excerpt":"记录自己学习typescript的过程，本节基础内容部分摘抄自慕课网教程，以后复杂部分尽量会用自己的理解来写 typescript的基本类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 布尔值1let isDone: boolean = false","text":"记录自己学习typescript的过程，本节基础内容部分摘抄自慕课网教程，以后复杂部分尽量会用自己的理解来写 typescript的基本类型TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。 布尔值1let isDone: boolean = false 数字和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015中引入的二进制和八进制字面量。 1234let decLiteral: number = 20let hexLiteral: number = 0x14let binaryLiteral: number = 0b10100let octalLiteral: number = 0o24 字符串1let name: string = `Hello, my name is $&#123; name &#125;` 数组两种方式：第一种，可以在元素类型后面接上 []；第二种，数组泛型，Array&lt;元素类型&gt; 123let list: number[] = [1, 2, 3]// 或者let list: Array&lt;number&gt; = [1, 2, 3] 元组 Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string 和 number 类型的元组。 123let x: [string, number]x = ['hello', 10] // OKx = [10, 'hello'] // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)) // OKconsole.log(x[1].substr(1)) // Error, 'number' 不存在 'substr' 方法 当访问一个越界的元素，会使用联合类型替代： 12345x[3] = 'world' // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()) // OK, 'string' 和 'number' 都有 toStringx[6] = true // Error, 布尔不是(string | number)类型 注意：自从 TyeScript 3.1 版本之后，访问越界元素会报错，我们不应该再使用该特性。 枚举12enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green 默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号： 12enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green 或者，全部都采用手动赋值： 12enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green 枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字： 1234enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2]console.log(colorName) // 显示'Green'因为上面代码里它的值是2 any1234let notSure: any = 4notSure = 'maybe a string instead'notSure = falselet list: any[] = [1, true, 'free'] void表示没有任何类型 123function warnUser(): void &#123; console.log('This is my warning message')&#125; 声明一个 void 类型的变量没有什么大用，因为你只能为它赋予 undefined 和 null： 1let unusable: void = undefined null 和 undefinedTypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大： 12let u: undefined = undefinedlet n: null = null 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把 null 和 undefined 赋值给 number 类型的变量。 然而，当你指定了 --strictNullChecks 标记，null 和 undefined 只能赋值给 void 和它们各自，这能避免 很多常见的问题。 也许在某处你想传入一个 string 或 null 或 undefined，你可以使用联合类型 string | null | undefined。 never表示的是那些永不存在的值的类型。 例如， never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。 never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。 下面是一些返回 never 类型的函数： 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message)&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(\"Something failed\")&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; objectobject 表示非原始类型，也就是除 number，string，boolean，symbol，null或undefined 之外的类型。 使用 object 类型，就可以更好的表示像 Object.create 这样的 API。例如： 123456789declare function create(o: object | null): voidcreate(&#123; prop: 0 &#125;) // OKcreate(null) // OKcreate(42) // Errorcreate('string') // Errorcreate(false) // Errorcreate(undefined) // Error 类型断言通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。 类型断言有两种形式。 其一是“尖括号”语法： 123let someValue: any = 'this is a string'let strLength: number = (&lt;string&gt;someValue).length 另一个为 as 语法： 123let someValue: any = 'this is a string'let strLength: number = (someValue as string).length 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"typescript","slug":"学习笔记/typescript","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/typescript/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://blog.xiaoz.site/tags/typescript/"}]},{"title":"多iconfont项目共用方案","slug":"iconfont","date":"2019-05-08T02:11:51.000Z","updated":"2019-09-06T06:15:25.720Z","comments":true,"path":"2019/05/08/iconfont/","link":"","permalink":"https://blog.xiaoz.site/2019/05/08/iconfont/","excerpt":"大多数情况下一个项目只需要一个iconfont项目，但是在某些特殊情况下，需要不止一个iconfont项目共同使用，这里提供一个方案： 1. 在项目中设置单独的前缀和FontFamily（最重要的一步）","text":"大多数情况下一个项目只需要一个iconfont项目，但是在某些特殊情况下，需要不止一个iconfont项目共同使用，这里提供一个方案： 1. 在项目中设置单独的前缀和FontFamily（最重要的一步） 2. 按需求在项目中用Unicode 或者 Font class 的方式引入即可(1) Unicode方式： 使用 (2) Font class 方式： 使用 (3) 需要多色时使用Js方式： 使用 效果","categories":[{"name":"css","slug":"css","permalink":"https://blog.xiaoz.site/categories/css/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://blog.xiaoz.site/tags/tips/"}]},{"title":"工作中总结的问题","slug":"work-tips","date":"2019-04-26T01:56:55.000Z","updated":"2020-10-12T07:00:17.085Z","comments":true,"path":"2019/04/26/work-tips/","link":"","permalink":"https://blog.xiaoz.site/2019/04/26/work-tips/","excerpt":"各种杂项meta 怎么写1234567&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;&lt;meta name=\"renderer\" content=\"webkit\" /&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt;&lt;meta name=\"fragment\" content=\"!\" /&gt;&lt;meta name=\"keywords\" content=\"政府采购网, 政府采购, 招标, 投标\" /&gt;&lt;meta name=\"description\" content=\"政府采购网\" /&gt; 禁止 a 标签加上 disabled 后还可以点击123a[disabled] &#123; pointer-events: none;&#125;","text":"各种杂项meta 怎么写1234567&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" /&gt;&lt;meta name=\"renderer\" content=\"webkit\" /&gt;&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt;&lt;meta name=\"fragment\" content=\"!\" /&gt;&lt;meta name=\"keywords\" content=\"政府采购网, 政府采购, 招标, 投标\" /&gt;&lt;meta name=\"description\" content=\"政府采购网\" /&gt; 禁止 a 标签加上 disabled 后还可以点击123a[disabled] &#123; pointer-events: none;&#125; 防止在打印时出现链接地址12345@media print &#123; a[href]:after &#123; content: none !important; &#125;&#125; 文字过长显示省略号(除火狐)1234567.ellipsis &#123; overflow: hidden; text-overflow: ellipsis; -o-text-overflow: ellipsis; white-space: nowrap; word-break: keep-all;&#125; 防止 ie 自动弹出确认框123window.opener = null;window.open(\"\", \"_self\", \"\");window.close(); 点击下载123456789101112131415161718192021222324252627282930313233// 方法一var downloadFile = function(fileName, filePath) &#123; var form = $(\"&lt;form style='display:none'&gt;&lt;/form&gt;\"); form.appendTo(\"body\"); form .attr( \"action\", \"$&#123;devhost&#125;/fd0.action?filePath=\" + filePath + \"&amp;fileName=\" + fileName ) .attr(\"method\", \"POST\"); form.submit();&#125;;// 方法二var iframe = $(\"&lt;iframe style='display:none;'&gt;&lt;/iframe&gt;\");iframe.attr(\"src\", action + \"?\" + $.param(params));iframe.appendTo(\"body\");// 方法三$http .get(action, &#123; params: params, responseType: \"blob\" &#125;) .then(function(response) &#123; console.log(response); var url = window.URL.createObjectURL(new Blob([response.data])); var link = document.createElement(\"a\"); link.href = url; var fileName = response .headers(\"Content-Disposition\") .split(\"filename=\")[1]; link.setAttribute(\"download\", decodeURIComponent(fileName)); document.body.appendChild(link); link.click(); &#125;); 遇到资源路径的问题时，使用 base 标签1&lt;base href=\"/admin-app/\" /&gt; delete 是 ie8 的关键字，方法调用时写成这样的形式1xxx[\"delete\"].xxx(); 解决 ie8 不支持 background-size:cover; 图片覆盖1filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='*.jpg', sizingMethod='scale'); 解决 ie8 不能访问 https 协议网站 失效了。。。 ssllabs –&gt; 客户端和服务器端加密算法不一致，需要在服务器端进行配置 ie8 不支持 new Date(yyyy-mm-dd)new Date(yyyy-mm-dd.replace(/-/g, &#39;/&#39;)) ie8 不支持 Access-Control-Allow-Origin: * 会导致跨域问题 使用 jsonp ie8 手动设置允许跨域 window.open 打开 ajax 返回的链接会被拦截，用以下办法处理12345var newTab = window.open(\"about:blank\");xxx.get().then(function(data) &#123; //使用replace，新页面不会出现后退，如果用 location.href='xxx'，会有后退 newTab.location.replace(data.content.content);&#125;); ie iframe 透明&lt;iframe allowTransparency=&quot;true&quot; /&gt; iframe 里 body 也要设为背景透明 https 跳转到 http 强制带上 referrer referrer 属性可返回载入当前文档的文档的 URL &lt;meta content=&quot;always&quot; name=&quot;referrer&quot;&gt; 函数注释写法 jsdoc1234567/** * @func 标识一个函数 * @desc 详细描述和说明 * @global 全局标识 * @param &#123;number&#125; a - 参数a * @returns &#123;boolean&#125; 返回值 */ 按键时转换小写转大写1&lt;input onkeyup=\"this.value = this.value.toUpperCase().trim();\" /&gt; 关于跨域跨域资源共享 CORS 详解Enable CORS 垂直居中123456&lt;div class=\"img_wrap\"&gt; &lt;img src=\"wgs.jpg\" /&gt;&lt;/div&gt;.img_wrap&#123; // 不能加浮动（若增加一个父级元素） width: 400px; height: 300px;display: table-cell; //主要是这个属性 vertical-align: middle; text-align:center; &#125; 离开或刷新页面进行提示1234567891011121314151617181920//检测离开页面提醒操作var UnloadConfirm = &#123;&#125;;UnloadConfirm.MSG_UNLOAD = \"确定要放弃编辑吗？您离开后数据将不会被保存。\";UnloadConfirm.set = function(text) &#123; window.onbeforeunload = function(e) &#123; e = e || window.event; // 兼容ie8 ie8的退出显示这里的数据 e.returnValue = \"确定要放弃编辑吗？您离开后数据将不会被保存。\"; return text; &#125;;&#125;;UnloadConfirm.clear = function() &#123; window.onbeforeunload = function() &#123;&#125;;&#125;;UnloadConfirm.set(UnloadConfirm.MSG_UNLOAD);//选择离开才会执行window.onunload = function whenUnload() &#123; // TODO&#125;; UMD: 通用模块规范123456789101112131415161718(function(root, factory) &#123; if (typeof define === \"function\" &amp;&amp; define.amd) &#123; // AMD define([\"jquery\"], factory); &#125; else if (typeof exports === \"object\") &#123; // Node, CommonJS之类的 module.exports = factory(require(\"jquery\")); &#125; else &#123; // 浏览器全局变量(root 即 window) root.returnExports = factory(root.jQuery); &#125;&#125;)(this, function($) &#123; // 方法 function myFunc() &#123;&#125; // 暴露公共方法 return myFunc;&#125;); 电话号码中间四位变 *1234function hideMobileMid(mobile) &#123; var reg = /^(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)$/; return mobile.replace(reg, \"$1****$2\");&#125; 防止 body 滚动，且 body 带有滚动条1234567891011121314/* 为body添加样式 */.fixed-body-hook &#123; position: fixed; width: 100%; height: 100%; left: 0; overflow-y: scroll;&#125;/* 或 */.fixed-body-hook &#123; overflow: hidden; /* position: relative; */ width: calc(100% - 17px);&#125; 12345678// 打开弹窗时，阻止body滚动top = $(document).scrollTop(); // 获取当前滚动偏移量$body.css(\"top\", -1 * top); // 为body设置top$body.addClass(\"fixed-body-hook\"); // 为body增加fixed样式// 还原body滚动$body.removeClass(\"fixed-body-hook\");$body.css(\"top\", \"\");$(document).scrollTop(top); 最新手机正则ChinaMobilePhoneNumberRegex 获取图片原始大小12345678910111213function getNaturalSize(element) &#123; var natureSize = &#123;&#125;; if (element.naturalWidth &amp;&amp; element.naturalHeight) &#123; natureSize.width = element.naturalWidth; natureSize.height = element.naturalHeight; &#125; else &#123; var img = new Image(); img.src = element.src; natureSize.width = img.width; natureSize.height = img.height; &#125; return natureSize;&#125; 获取 iframe 高度ele.contentWindow.document.documentElement.scrollHeight 千分位1234Number(\"1234564\").toLocaleString();vartoThousands = function(number) &#123; return (number + \"\").replace(/(\\d)(?=(\\d&#123;3&#125;)+$)/g, \"$1,\");&#125;; 防止默认填充密码12345678&lt;!-- 隐藏的input, 为了禁用浏览器的用户名密码表单自动填充 --&gt;&lt;input type=\"password\" style=\"height: 0;padding: 0;width: 0;border: 0;position: absolute;\"/&gt;&lt;!-- password上加属性 --&gt;&lt;input type=\"password\" autocomplete=\"new-password\" /&gt; 生成证书12345678910111213141516171819第一步:打开: https:&#x2F;&#x2F;myssl.com&#x2F;create_test_cert.html第二步:填写参数:证书类型: 服务器证书加密算法: RSA域名: gmsoft.com (这个不重要, chrome58 以后不会使用它来验证域名了)高级设置:备用名称: 填写要注册的域名(最后列出了目前注册的, 可以在此基础上增加 更新证书)密钥强度: 2048签名哈希算法: SHA256--------------------------------------------------------------------------------目前证书注册的域名, 如有需要请增加并重新生成证书:*.gmsoft.com,*.cqzcjdev.com,*.cqzcjshow.com,*.cqzcjtest.com,*.cqzcjtestoper.com,*.gpwdevcom,*.gpwtest.com,*.gpwshow.com,*.gpwtestoper.com,*.culturedev.com,*.culturetest.com,*.culturetestoper.com,*.cultureshow.com,*.wlwculture.com,*.csmhtest.com,*.lgmhtest.com,*.yzmhtest.com,*.dgmhtest.com.conf 根据 id 从树结构中取对应节点，利用 throw 跳出递归12345678910111213141516171819202122const getNodeById = (id, menus) =&gt; &#123; // 定义变量保存当前结果路径 let result; function getNode(nodes) &#123; forEach(nodes, (item) =&gt; &#123; // 找到符合条件的节点，通过throw终止掉递归 if (item.key === id) &#123; result = item; throw \"GOT IT!\"; &#125; if (item.children &amp;&amp; item.children.length &gt; 0) &#123; getNode(item.children); &#125; &#125;); &#125; try &#123; getNode(menus); &#125; catch (e) &#123; console.log(e); &#125; return result;&#125;; 获取元素到 body 的距离12345678function getOffsetTopByBody(el) &#123; let offsetTop = 0; while (el &amp;&amp; el.tagName !== \"BODY\") &#123; offsetTop += el.offsetTop; el = el.offsetParent; &#125; return offsetTop;&#125; angular1.x用$last 控制最后一个元素的 class12&lt;li ng-repeat=\"rule in rules | orderBy:\\'-date\\'\" class=\"ellipsis\"''ng-class=\"&#123;\\'last\\':$last&#125;\" ui-sref=\"rules.detail(&#123;id: rule.id&#125;)\"&gt; 绑定 html1234567app.filter('to_trusted', ['$sce', function ($sce) &#123; return function (text) &#123; return $sce.trustAsHtml(text); &#125;;&#125;]);html code:&lt;p ng-bind-html=\"currentWork.description | to_trusted\"&gt;&lt;/p&gt; angular 的 JSON 字符串转对象12s.str = angular.fromJson(s.jsonStr);s.json = angular.toJson(s.obj); 用 angular 省略号：1234567891011&lt;label ng-if=\"!item.expand\" style=\"word-break: break-all;font-weight: normal\"&gt; &#123;&#123;item.content | limitTo:120&#125;&#125;&lt;span ng-if=\"item.content.length&gt;120\" &gt;....&lt;/span &gt; &lt;a ng- if=\"item.content.length&gt;120\" ng-click=\"item.expand=true\" &gt;更多&lt;/a &gt;&lt;/label&gt;&lt;label ng-if=\"item.expand\" style=\"word-break: break-all;font-weight: normal\" &gt;&#123;&#123;item.content &#125;&#125;&lt;a ng-click=\"item.expand=false\"&gt;收起&lt;/a&gt;&lt;/label&gt; ng-option 的使用，可以绑定 ng-model 的值为 as 前面的属性的值1234567&lt;select class=\"form-control\" ng-model=\"marketId\" ng-options=\"a.id as a.adminAreaName for a in areas\"&gt; &lt;option value=\"\"&gt;--请选择--&lt;/option&gt;&lt;/select&gt; 这里有一个坑，如果要初始化选中项，ng-model 必须是 String 类型 为异步加载的元素绑定事件,放在 $timeout 里123456789101112131415$timeout(function() &#123; var width; $(\".ellipsis\").each(function() &#123; width = $(this) .css(\"width\") .slice(0, -2); if ($(this)[0].scrollWidth &gt; width) $(this).tipsy(&#123; fade: true &#125;); else &#123; $(this).removeAttr(\"title\"); &#125; $(this).click(function() &#123; $(\".tipsy\").remove(); &#125;); &#125;);&#125;); ng-if 的坑 ng-show 和 ng-hide 是不自带作用域的，而 ng-if 则自己创建了一级作用域。在用的时候，两者就是有差别的，比如说内部元素访问外层定义的变量，就需要使用$parent 语法了。 angular 自定义验证123456var 验证方法 = function(输入)&#123; ... //对输入验证 s.editform.provider.$setValidity('has', false); &#125; s.editform.provider.$parsers.push(验证方法); s.editform.provider.$formatters.push(验证方法); angular 阻止事件冒泡1234&lt;div ng-click=\"doSomething($event)\" /&gt;;s.doSomething = function(e) &#123; e.stopPropagation();&#125;; angular 自定义指令函数传参angular 自定义指令作用域&amp;–传递引用 angular 自定义指令 scope 里不能用 name，和 form 验证有冲突angular 的几种 watch $watchGroup 的第一个参数要传数组，$watchCollection 的第一个参数要传对象 监视对象和数组而且监视层次不是特别深，优先使用$watchCollection, $watchCollection 可以方便的监视数组的插入，移除。 要同时监视多个变量并执行同一逻辑使用$watchGroup 除此一般情况下使用$watch,如果你知道数据结构的深度，可以直接这样监视。 当第三个参数 true，表示深度监测，如果 watch 的变量比较复杂，效率会变低。 好用的 npm 包 nodemon 自动重新启动服务器 rimraf 删除文件 cross-env 跨平台地设置及使用环境变量 concurrently 同时启用多个持久服务 fkill 跨平台杀掉进程 install-peerdeps 同时安装包的依赖 husky 在 commit 之前执行其他操作，如 lint react-helmet 为 react 项目设置头部 npx 从本地 node_modules/.bin 中执行命令 emma-cli 搜索方式安装包 持续更新中…","categories":[{"name":"work","slug":"work","permalink":"https://blog.xiaoz.site/categories/work/"}],"tags":[{"name":"tips","slug":"tips","permalink":"https://blog.xiaoz.site/tags/tips/"}]}],"categories":[{"name":"面试","slug":"面试","permalink":"https://blog.xiaoz.site/categories/%E9%9D%A2%E8%AF%95/"},{"name":"learn","slug":"learn","permalink":"https://blog.xiaoz.site/categories/learn/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"typescript","slug":"学习笔记/typescript","permalink":"https://blog.xiaoz.site/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/typescript/"},{"name":"work","slug":"work","permalink":"https://blog.xiaoz.site/categories/work/"},{"name":"文档","slug":"文档","permalink":"https://blog.xiaoz.site/categories/%E6%96%87%E6%A1%A3/"},{"name":"css","slug":"css","permalink":"https://blog.xiaoz.site/categories/css/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.xiaoz.site/tags/js/"},{"name":"tips","slug":"tips","permalink":"https://blog.xiaoz.site/tags/tips/"},{"name":"react","slug":"react","permalink":"https://blog.xiaoz.site/tags/react/"},{"name":"typescript","slug":"typescript","permalink":"https://blog.xiaoz.site/tags/typescript/"}]}